"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const _set = require("lodash.set");
const _merge = require("lodash.merge");
class FileDb2 {
    constructor(config) {
        this.needsWriteFileAccess = true;
        this.config = {
            path: './../db/',
            primaryKeyColumn: 'userId',
        };
        if (config) {
            this.config = _merge(this.config, config);
        }
    }
    install(app) {
        app.$db = this;
        if (!this.config.path) {
            throw new Error(`Couldn't install FileDb2 plugin. Path is missing`);
        }
        if (!fs.existsSync(path.join(this.config.path))) {
            FileDb2.mkDirByPathSync(path.join(this.config.path), false);
        }
    }
    uninstall(app) {
    }
    /**
     * Returns object for given primaryKey
     * @param {string} primaryKey
     * @return {Promise<any>}
     */
    async load(primaryKey) {
        if (!this.config.path) {
            throw new Error(`Couldn't use FileDb2 plugin. Path is missing`);
        }
        const pathToFile = path.join(this.config.path, `${primaryKey}.json`);
        if (!fs.existsSync(pathToFile)) {
            return Promise.resolve([]);
        }
        const data = await this.readFile(pathToFile); // tslint:disable-line
        return Promise.resolve(JSON.parse(data));
    }
    async save(primaryKey, key, data) {
        if (!this.config.path) {
            throw new Error(`Couldn't install FileDb2 plugin. Path is missing`);
        }
        const pathToFile = path.join(this.config.path, `${primaryKey}.json`);
        if (fs.existsSync(pathToFile)) {
            const oldDataContent = await this.readFile(pathToFile);
            const oldData = JSON.parse(oldDataContent);
            _set(oldData, key, data);
            return this.saveFile(pathToFile, oldData);
        }
        else {
            const newData = {}; // tslint:disable-line
            _set(newData, key, data);
            return this.saveFile(pathToFile, newData);
        }
    }
    async delete(primaryKey) {
    }
    async readFile(filename) {
        return new Promise((resolve, reject) => {
            fs.readFile(filename, 'utf8', (err, data) => {
                if (err) {
                    return reject(err);
                }
                resolve(data);
            });
        });
    }
    async saveFile(filename, data) {
        return new Promise((resolve, reject) => {
            fs.writeFile(filename, JSON.stringify(data, null, '\t'), (err) => {
                if (err) {
                    console.log(err);
                    return reject(err);
                }
                resolve();
            });
        });
    }
    /**
     * Creates paths recursively
     * @param {string} targetDir
     * @param {boolean} isRelativeToScript
     */
    static mkDirByPathSync(targetDir, isRelativeToScript) {
        const sep = path.sep;
        const initDir = path.isAbsolute(targetDir) ? sep : '';
        const baseDir = isRelativeToScript ? __dirname : '.';
        targetDir.split(sep).reduce((parentDir, childDir) => {
            const curDir = path.resolve(baseDir, parentDir, childDir);
            try {
                if (!fs.existsSync(curDir)) {
                    fs.mkdirSync(curDir);
                    console.log(`Directory ${curDir} created!`);
                }
            }
            catch (err) {
                if (err.code !== 'EEXIST') {
                    throw err;
                }
                console.log(`Directory ${curDir} already exists!`);
            }
            return curDir;
        }, initDir);
    }
}
exports.FileDb2 = FileDb2;
//# sourceMappingURL=FileDb2.js.map