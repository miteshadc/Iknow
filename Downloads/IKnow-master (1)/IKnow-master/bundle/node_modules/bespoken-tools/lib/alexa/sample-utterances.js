"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const file_util_1 = require("../core/file-util");
class SampleUtterances {
    constructor() {
        this.samples = {};
    }
    static fromFile(file, callback) {
        file_util_1.FileUtil.readFile(file, function (data) {
            if (data !== null) {
                let sampleUtterances = new SampleUtterances();
                try {
                    sampleUtterances.parseFlatFile(data.toString());
                    callback(sampleUtterances);
                }
                catch (e) {
                    callback(null, e.message);
                }
            }
            else {
                let error = "File not found: " + file;
                callback(null, error);
            }
        });
    }
    static fromJSON(sampleUtterancesJSON) {
        let sampleUtterances = new SampleUtterances();
        for (let intent of Object.keys(sampleUtterancesJSON)) {
            sampleUtterances.samples[intent] = sampleUtterancesJSON[intent];
        }
        return sampleUtterances;
    }
    defaultUtterance() {
        let firstIntent = Object.keys(this.samples)[0];
        return this.samples[firstIntent][0];
    }
    intentForUtterance(phraseString) {
        let phrase = new Phrase(phraseString);
        let matchedIntent = null;
        for (let intent of Object.keys(this.samples)) {
            let samples = this.samples[intent];
            for (let sample of samples) {
                if (phrase.matchesUtterance(sample)) {
                    matchedIntent = new UtteredIntent(intent, phraseString, new Phrase(sample));
                    break;
                }
            }
            if (matchedIntent !== null) {
                break;
            }
        }
        return matchedIntent;
    }
    hasIntent(intent) {
        return intent in this.samples;
    }
    parseFlatFile(fileData) {
        let lines = fileData.split("\n");
        for (let line of lines) {
            if (line.trim().length === 0) {
                continue;
            }
            let index = line.indexOf(" ");
            if (index === -1) {
                throw Error("Invalid sample utterance: " + line);
            }
            let intent = line.substr(0, index);
            let sample = line.substr(index).trim();
            let intentSamples = [];
            if (intent in this.samples) {
                intentSamples = this.samples[intent];
            }
            else {
                this.samples[intent] = intentSamples;
            }
            intentSamples.push(sample);
        }
    }
}
exports.SampleUtterances = SampleUtterances;
class Phrase {
    constructor(phrase) {
        this.phrase = phrase;
        this.slots = [];
        this.normalizedPhrase = null;
        this.normalizeSlots(this.phrase);
    }
    normalizeSlots(utterance) {
        let slotlessUtterance = "";
        let index = 0;
        let done = false;
        while (!done) {
            let startSlotIndex = utterance.indexOf("{", index);
            if (startSlotIndex !== -1) {
                let endSlotIndex = utterance.indexOf("}", startSlotIndex);
                let slotValue = utterance.substr(startSlotIndex + 1, endSlotIndex - (startSlotIndex + 1));
                this.slots.push(slotValue);
                slotlessUtterance += utterance.substr(index, startSlotIndex - index + 1) + "}";
                index = endSlotIndex + 1;
            }
            else {
                slotlessUtterance += utterance.substr(index);
                done = true;
            }
        }
        this.normalizedPhrase = slotlessUtterance;
    }
    matchesUtterance(otherPhraseString) {
        return this.matches(new Phrase(otherPhraseString));
    }
    matches(otherPhrase) {
        return this.normalizedPhrase.toLowerCase() === otherPhrase.normalizedPhrase.toLowerCase();
    }
}
exports.Phrase = Phrase;
class UtteredIntent {
    constructor(intentName, utterance, matchedPhrase) {
        this.intentName = intentName;
        this.utterance = utterance;
        this.matchedPhrase = matchedPhrase;
    }
    slotCount() {
        return this.matchedPhrase.slots.length;
    }
    slotName(index) {
        return this.matchedPhrase.slots[index];
    }
    slotValue(index) {
        return new Phrase(this.utterance).slots[index];
    }
    toJSON() {
        let json = {};
        for (let i = 0; i < this.slotCount(); i++) {
            json[this.slotName(i)] = this.slotValue(i);
        }
        return json;
    }
}
exports.UtteredIntent = UtteredIntent;
//# sourceMappingURL=sample-utterances.js.map