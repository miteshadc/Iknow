"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const async = require("async");
const logging_helper_1 = require("../core/logging-helper");
const aws = require("aws-sdk");
const exec = require("child_process").exec;
let logger = "LambdaDeploy";
class LambdaDeploy {
    constructor() {
        this.codeDirectory = function () {
            let epoch_time = +new Date();
            return os.tmpdir() + "/" + this.lambdaConfig.AWS_FUNCTION_NAME + "-" + epoch_time;
        };
        this.nativeZipFiles = function (codeDirectory, callback) {
            let ms_since_epoch = new Date().getTime();
            let filename = this.lambdaConfig.AWS_FUNCTION_NAME + "-" + ms_since_epoch + ".zip";
            let zipfile = path.join(os.tmpdir(), filename);
            let cmd = "zip -r " + zipfile + " .";
            exec(cmd, {
                cwd: codeDirectory,
                maxBuffer: 50 * 1024 * 1024
            }, function (err) {
                if (err !== null) {
                    return callback(err, null);
                }
                let data = fs.readFileSync(zipfile);
                callback(null, data);
            });
            logging_helper_1.LoggingHelper.verbose(logger, "Packaged zip created: " + zipfile);
        };
        this.zipFiles = function (codeDirectory, callback) {
            callback(null);
        };
    }
    static create(lambdaFolder, lambdaConfig) {
        let instance = new LambdaDeploy();
        instance.lambdaConfig = lambdaConfig;
        instance.lambdaFolder = lambdaFolder;
        return instance;
    }
    deploy(callback) {
        let self = this;
        let regions = this.lambdaConfig.AWS_REGION.split(",");
        this.archive(function (err, buffer) {
            if (err) {
                throw err;
            }
            logging_helper_1.LoggingHelper.verbose(logger, "Reading zip file to memory");
            let params = self.params(buffer);
            async.map(regions, cb, function (err, results) {
                if (err) {
                    throw err;
                }
                else {
                    console.log("Zip file(s) done uploading.");
                    console.log("Enter this ARN(s) on the Configuration tab of your skill:");
                    results.map((result) => {
                        console.log();
                        console.log("\t" + result.FunctionArn);
                        console.log();
                    });
                    if (callback) {
                        callback(null);
                    }
                }
            });
            function cb(region, callback) {
                logging_helper_1.LoggingHelper.verbose(logger, "Uploading zip file to lambda " + region + " with parameters:");
                self.logParams(params);
                let aws_security = {
                    accessKeyId: self.lambdaConfig.AWS_ACCESS_KEY_ID,
                    secretAccessKey: self.lambdaConfig.AWS_SECRET_ACCESS_KEY,
                    region: region
                };
                aws.config.update(aws_security);
                let lambda = new aws.Lambda({
                    apiVersion: "2015-03-31"
                });
                return lambda.getFunction({
                    "FunctionName": params.FunctionName
                }, function (err) {
                    if (err) {
                        return self.uploadNew(lambda, params, callback);
                    }
                    return self.uploadExisting(lambda, params, callback);
                });
            }
        });
    }
    ;
    logParams(params) {
        let buff = params.Code.ZipFile;
        params.Code.ZipFile = "<" + buff.length + " bytes>";
        logging_helper_1.LoggingHelper.verbose(logger, JSON.stringify(params, null, 2));
        params.Code.ZipFile = buff;
    }
    uploadExisting(lambda, params, callback) {
        return lambda.updateFunctionCode({
            "FunctionName": params.FunctionName,
            "ZipFile": params.Code.ZipFile,
            "Publish": params.publish
        }, function (err, data) {
            if (err) {
                return callback(err, data);
            }
            return lambda.updateFunctionConfiguration({
                "FunctionName": params.FunctionName,
                "Description": params.Description,
                "Handler": params.Handler,
                "MemorySize": params.MemorySize,
                "Role": params.Role,
                "Timeout": params.Timeout,
                "VpcConfig": params.VpcConfig
            }, function (err, data) {
                logging_helper_1.LoggingHelper.verbose(logger, "Lambda function was updated: " + params.FunctionName);
                return callback(err, data);
            });
        });
    }
    uploadNew(lambda, params, callback) {
        return lambda.createFunction(params, function (err, functionData) {
            if (!err) {
                logging_helper_1.LoggingHelper.verbose(logger, "Lambda function was created: " + params.FunctionName);
            }
            else {
                return callback(err, functionData);
            }
            console.log("Waiting for AWS to propagate the changes");
            setTimeout(() => {
                return lambda.addPermission({
                    "FunctionName": params.FunctionName,
                    "Action": "lambda:InvokeFunction",
                    "Principal": "alexa-appkit.amazon.com",
                    "StatementId": new Date().getTime() + ""
                }, function (err, data) {
                    if (!err) {
                        logging_helper_1.LoggingHelper.verbose(logger, "Alexa trigger was added to the function");
                    }
                    return callback(err, functionData);
                });
            }, 3000);
        });
    }
    params(buffer) {
        let params = {
            FunctionName: this.lambdaConfig.AWS_FUNCTION_NAME,
            Code: {
                ZipFile: buffer
            },
            Handler: this.lambdaConfig.AWS_HANDLER,
            Role: this.lambdaConfig.AWS_ROLE_ARN,
            Runtime: this.lambdaConfig.AWS_RUNTIME,
            Description: this.lambdaConfig.AWS_DESCRIPTION,
            MemorySize: this.lambdaConfig.AWS_MEMORY_SIZE,
            Timeout: this.lambdaConfig.AWS_TIMEOUT,
            Publish: this.lambdaConfig.AWS_PUBLISH,
            VpcConfig: {}
        };
        if (this.lambdaConfig.AWS_FUNCTION_VERSION) {
            params.FunctionName += ("-" + this.lambdaConfig.AWS_FUNCTION_VERSION);
        }
        if (this.lambdaConfig.AWS_VPC_SUBNETS && this.lambdaConfig.AWS_VPC_SECURITY_GROUPS) {
            params.VpcConfig = {
                "SubnetIds": this.lambdaConfig.AWS_VPC_SUBNETS.split(","),
                "SecurityGroupIds": this.lambdaConfig.AWS_VPC_SECURITY_GROUPS.split(",")
            };
        }
        return params;
    }
    ;
    archive(callback) {
        return this.lambdaConfig.PREBUILT_DIRECTORY
            ? this.archivePrebuilt(callback) : this.buildAndArchive(callback);
    }
    buildAndArchive(callback) {
        let self = this;
        let codeDirectory = this.codeDirectory();
        this.cleanDirectory(codeDirectory, function (err) {
            if (err) {
                return callback(err);
            }
            logging_helper_1.LoggingHelper.verbose(logger, "Moving files to temporary directory");
            self.copyFiles(self.lambdaFolder, codeDirectory, true, function (err) {
                if (err) {
                    return callback(err);
                }
                logging_helper_1.LoggingHelper.verbose(logger, "Running npm install --production");
                self.npmInstall(codeDirectory, function (err) {
                    if (err) {
                        return callback(err);
                    }
                    self.postInstallScript(codeDirectory, function (err) {
                        if (err) {
                            return callback(err);
                        }
                        logging_helper_1.LoggingHelper.verbose(logger, "Zipping deployment package");
                        if (process.platform !== "win32") {
                            self.nativeZipFiles(codeDirectory, callback);
                        }
                        else {
                            self.zipFiles(codeDirectory, callback);
                        }
                    });
                });
            });
        });
    }
    postInstallScript(codeDirectory, callback) {
        callback(null);
    }
    npmInstall(codeDirectory, callback) {
        exec("npm -s install --production --prefix " + codeDirectory, function (err) {
            if (err) {
                return callback(err);
            }
            return callback(null);
        });
    }
    archivePrebuilt(callback) {
        callback(null);
    }
    copyFiles(src, dest, excludeNodeModules, callback) {
        let excludes = [".git*", "*.swp", ".editorconfig", "deploy.env", "*.log", "build/", ".DS_Store"];
        let excludeGlobs = [];
        if (this.lambdaConfig.EXCLUDE_GLOBS) {
            excludeGlobs = this.lambdaConfig.EXCLUDE_GLOBS.split(" ");
        }
        let excludeArgs = excludeGlobs
            .concat(excludes)
            .concat(excludeNodeModules ? ["node_modules"] : [])
            .map(function (exclude) {
            return "--exclude=" + exclude;
        }).join(" ");
        exec("mkdir -p " + dest, function (err) {
            if (err) {
                return callback(err);
            }
            let cmd = "rsync -rL " + excludeArgs + " " + src.trim() + "/ " + dest;
            exec(cmd, function (err, stdout, stderr) {
                if (err) {
                    return callback(err);
                }
                return callback(null);
            });
        });
    }
    cleanDirectory(codeDirectory, callback) {
        exec("rm -rf " + codeDirectory, function (err) {
            if (err) {
                throw err;
            }
            fs.mkdir(codeDirectory, function (err) {
                if (err) {
                    throw err;
                }
                return callback(null);
            });
        });
    }
    ;
}
exports.LambdaDeploy = LambdaDeploy;
//# sourceMappingURL=lambda-deploy.js.map