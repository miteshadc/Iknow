"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const logging_helper_1 = require("../core/logging-helper");
const module_manager_1 = require("./module-manager");
const chalk = require("chalk");
let Logger = "BST-LAMBDA";
class LambdaServer {
    constructor(file, port, verbose, functionName) {
        this.file = file;
        this.port = port;
        this.verbose = verbose;
        this.functionName = functionName;
        this.requests = [];
        this.server = null;
    }
    start(callback) {
        let self = this;
        this.moduleManager = new module_manager_1.ModuleManager(process.cwd());
        this.moduleManager.start();
        this.server = http.createServer();
        this.server.listen(this.port);
        this.server.on("request", function (request, response) {
            self.requests.push(request);
            let requestBody = new Buffer("");
            request.on("data", function (chunk) {
                requestBody = Buffer.concat([requestBody, chunk]);
            });
            request.on("end", function () {
                const isPing = request.method === "GET" && request.url && request.url.indexOf("/localPing") !== -1;
                if (isPing) {
                    return response.end("ALIVE");
                }
                self.invoke(request, requestBody, response);
            });
        });
        this.server.on("listening", function () {
            logging_helper_1.LoggingHelper.debug(Logger, "LambdaServer started on port: " + self.server.address().port.toString());
            if (callback !== undefined && callback !== null) {
                callback();
            }
        });
    }
    stop(onStop) {
        this.moduleManager.stop();
        let request = null;
        for (request of this.requests) {
            try {
                request.socket.end();
            }
            catch (e) {
            }
        }
        this.server.close(function () {
            if (onStop !== undefined && onStop !== null) {
                onStop();
            }
        });
    }
    invoke(request, body, response) {
        let path;
        let handlerFunction;
        const context = new LambdaContext(request, body, response, this.verbose);
        const onlyUrl = request.url.split("?")[0];
        if (this.file) {
            path = this.file;
        }
        else {
            if (onlyUrl !== "/") {
                if (/(.*\..*\.)|(.*node_modules)/.test(onlyUrl)) {
                    context.fail(Error(`LambdaServer input url should not contain more than '.' or node_modules.  found: ${onlyUrl}`));
                    return;
                }
                const splitUrl = onlyUrl.split(".");
                path = splitUrl[0];
                handlerFunction = splitUrl[1];
            }
            else {
                context.fail(Error("You should provide the lambda file or pass it in the url"));
                return;
            }
        }
        logging_helper_1.LoggingHelper.debug(Logger, "Invoking Lambda: " + path);
        const lambda = this.moduleManager.module(path);
        try {
            const bodyToString = body.toString();
            const bodyJSON = JSON.parse(bodyToString === "" ? null : bodyToString);
            if (this.verbose) {
                console.log("Request:");
                console.log(JSON.stringify(bodyJSON, null, 2));
            }
            handlerFunction = handlerFunction ? handlerFunction : this.functionName ? this.functionName : "handler";
            Promise.resolve(lambda[handlerFunction](bodyJSON, context, function (error, result) {
                context.done(error, result);
            })).then((result) => {
                if (result) {
                    context.done(null, result);
                }
            }, (error) => context.done(error, null));
        }
        catch (e) {
            console.error(chalk.red(e.toString()));
            context.fail(e);
        }
    }
}
exports.LambdaServer = LambdaServer;
class LambdaContext {
    constructor(request, body, response, verbose) {
        this.request = request;
        this.body = body;
        this.response = response;
        this.verbose = verbose;
        this.awsRequestId = "N/A";
        this.callbackWaitsForEmptyEventLoop = true;
        this.functionName = "BST.LambdaServer";
        this.functionVersion = "N/A";
        this.memoryLimitInMB = -1;
        this.invokedFunctionArn = "N/A";
        this.logGroupName = "N/A";
        this.logStreamName = null;
        this.identity = null;
        this.clientContext = null;
    }
    fail(error) {
        this.done(error, null);
    }
    succeed(body) {
        this.done(null, body);
    }
    getRemainingTimeMillis() {
        return -1;
    }
    done(error, body) {
        let statusCode = 200;
        let contentType = "application/json";
        let bodyString = null;
        if (error === null) {
            bodyString = JSON.stringify(body);
            if (this.verbose) {
                console.log("Response:");
                console.log(JSON.stringify(body, null, 2));
            }
        }
        else {
            statusCode = 500;
            contentType = "text/plain";
            bodyString = "Unhandled Exception from Lambda: " + error.toString();
        }
        this.response.writeHead(statusCode, {
            "Content-Type": contentType
        });
        this.response.end(new Buffer(bodyString));
    }
}
//# sourceMappingURL=lambda-server.js.map