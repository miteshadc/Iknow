"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const global_1 = require("./global");
const string_util_1 = require("./string-util");
const logging_helper_1 = require("./logging-helper");
const net = require("net");
let Logger = "SOCKET";
class SocketHandler {
    constructor(socket, onMessage) {
        this.socket = socket;
        this.onMessage = onMessage;
        this.buffer = Buffer.from("");
        this.onCloseCallback = null;
        this.connected = true;
        let self = this;
        this.onDataCallback = function (data) {
            self.handleData(data);
        };
        this.socket.on("data", this.onDataCallback);
        this.socket.on("error", function (e) {
            if (self.connected) {
                logging_helper_1.LoggingHelper.debug(Logger, "SocketError From: " + self.remoteEndPoint() + " Error: " + e.code + " Message: " + e.message);
            }
        });
        this.socket.on("close", function () {
            if (self.connected) {
                if (self.onCloseCallback != null) {
                    self.onCloseCallback();
                }
                else {
                    logging_helper_1.LoggingHelper.debug(Logger, "Socket closed");
                }
            }
        });
    }
    static connect(host, port, onConnect, onMessage) {
        let socket = new net.Socket();
        let handler = new SocketHandler(socket, onMessage);
        handler.connected = false;
        socket.connect(port, host, function () {
            handler.connected = true;
            onConnect();
        });
        socket.on("error", function (error) {
            if (!handler.connected) {
                onConnect(error);
            }
        });
        return handler;
    }
    handleData(data) {
        if (data !== null) {
            this.buffer = Buffer.concat([this.buffer, data]);
        }
        const delimiterIndex = this.buffer.indexOf(global_1.Global.MessageDelimiter);
        if (delimiterIndex > -1) {
            const messageIDIndex = delimiterIndex - global_1.Global.MessageIDLength;
            let badMessage = messageIDIndex < 0;
            const message = this.buffer.slice(0, messageIDIndex);
            const messageIDString = this.buffer.slice(delimiterIndex - global_1.Global.MessageIDLength, delimiterIndex).toString();
            const messageID = parseInt(messageIDString);
            if (isNaN(messageID) || (messageID + "").length < 13) {
                badMessage = true;
            }
            if (badMessage) {
                logging_helper_1.LoggingHelper.error(Logger, "Bad message received: " + this.buffer.toString());
            }
            else {
                const socketMessage = new SocketMessage(message, messageID);
                logging_helper_1.LoggingHelper.debug(Logger, "DATA READ " + this.remoteEndPoint() + " ID: " + messageID + " MSG: "
                    + string_util_1.StringUtil.prettyPrint(socketMessage.messageForLogging()));
                this.onMessage(socketMessage);
            }
            this.buffer = this.buffer.slice(delimiterIndex + global_1.Global.MessageDelimiter.length);
            if (this.buffer.toString().indexOf(global_1.Global.MessageDelimiter) !== -1) {
                this.handleData(null);
            }
        }
    }
    send(socketMessage) {
        if (this.socket === null) {
            logging_helper_1.LoggingHelper.warn(Logger, "Writing message to closed socket: " + socketMessage.getMessageID());
            return;
        }
        const dataSent = socketMessage.isString() ? socketMessage.asString() : "< Binary Data >";
        logging_helper_1.LoggingHelper.debug(Logger, "DATA SENT " + this.remoteEndPoint() + " SEQUENCE: " + socketMessage.getMessageID() + " " + string_util_1.StringUtil.prettyPrint(dataSent));
        this.socket.write(socketMessage.getFullMessage(), null);
    }
    remoteAddress() {
        return this.socket.remoteAddress;
    }
    remoteEndPoint() {
        if (this.socket === null) {
            return "";
        }
        return this.socket.remoteAddress + ":" + this.socket.remotePort;
    }
    disconnect() {
        if (this.isOpen()) {
            this.socket.end();
            this.socket = null;
        }
    }
    isOpen() {
        return this.socket != null;
    }
}
exports.SocketHandler = SocketHandler;
class SocketMessage {
    constructor(message, sequenceNumber) {
        this.sequenceNumber = sequenceNumber;
        this.message = Buffer.from("");
        if (typeof message === "string") {
            this.message = Buffer.concat([this.message, Buffer.from(message)]);
        }
        else {
            this.message = Buffer.concat([this.message, message]);
        }
    }
    getMessageID() {
        return this.sequenceNumber ? this.sequenceNumber : new Date().getTime();
    }
    asString() {
        return this.message.toString();
    }
    isString() {
        return !/[\x00-\x1F]/.test(this.asString());
    }
    isJSON() {
        try {
            JSON.parse(this.asString());
            return true;
        }
        catch (error) {
            return false;
        }
    }
    asJSON() {
        return JSON.parse(this.asString());
    }
    messageForLogging() {
        return this.isString() ? this.asString() : "< Binary Data>";
    }
    getMessage() {
        return this.message;
    }
    getFullMessage() {
        const messageID = this.getMessageID();
        return Buffer.concat([this.message, Buffer.from(messageID.toString()), Buffer.from(global_1.Global.MessageDelimiter)]);
    }
    contains(stringToFind) {
        return this.asString().indexOf(stringToFind) > -1;
    }
}
exports.SocketMessage = SocketMessage;
//# sourceMappingURL=socket-handler.js.map