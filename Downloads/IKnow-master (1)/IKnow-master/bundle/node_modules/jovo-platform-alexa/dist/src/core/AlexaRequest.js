"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jovo_core_1 = require("jovo-core");
const _get = require("lodash.get");
const _set = require("lodash.set");
var ConfirmationStatus;
(function (ConfirmationStatus) {
    ConfirmationStatus["NONE"] = "NONE";
    ConfirmationStatus["CONFIRMED"] = "CONFIRMED";
    ConfirmationStatus["DENIED"] = "DENIED";
})(ConfirmationStatus = exports.ConfirmationStatus || (exports.ConfirmationStatus = {}));
/**
 * Thanks to @see http://choly.ca/post/typescript-json/
 */
class AlexaRequest {
    // JovoRequest implementation
    getAccessToken() {
        return _get(this, 'context.System.user.accessToken');
    }
    getInputs() {
        const inputs = {};
        const slots = this.getSlots();
        if (!slots) {
            return inputs;
        }
        Object.keys(slots).forEach((slot) => {
            const input = {
                name: slot,
                alexaSkill: slots[slot],
            };
            if (slots[slot].value) {
                input.value = slots[slot].value;
                input.key = slots[slot].value;
            }
            if (_get(slots[slot], 'resolutions.resolutionsPerAuthority[0].values[0]')) {
                input.key = _get(slots[slot], 'resolutions.resolutionsPerAuthority[0].values[0]').value.name;
                input.id = _get(slots[slot], 'resolutions.resolutionsPerAuthority[0].values[0]').value.id;
            }
            inputs[slot] = input;
        });
        return inputs;
    }
    setInputs(inputs) {
        Object.keys(inputs).forEach((key) => {
            const input = inputs[key];
            const slot = {
                name: input.name,
                value: input.value,
                confirmationStatus: 'NONE'
            };
            const alexaInput = input;
            if (alexaInput.alexaSkill) {
                _set(this, `request.intent.slots[${input.name}]`, alexaInput.alexaSkill);
            }
            else {
                _set(this, `request.intent.slots[${input.name}]`, slot);
            }
        });
        return this;
    }
    getLocale() {
        return _get(this, 'request.locale');
    }
    getSessionData() {
        return this.getSessionAttributes();
    }
    getState() {
        return _get(this.getSessionAttributes(), jovo_core_1.SessionConstants.STATE);
    }
    setSessionData(sessionData) {
        return this.setSessionAttributes(sessionData);
    }
    addSessionData(key, value) {
        return this.addSessionAttribute(key, value);
    }
    getSessionAttributes() {
        return _get(this, 'session.attributes');
    }
    getTimestamp() {
        return _get(this, 'request.timestamp');
    }
    getUserId() {
        return _get(this, 'session.user.userId') ||
            _get(this, 'context.System.user.userId');
    }
    /**
     * Returns audio capability of request device
     * @return {boolean}
     */
    hasAudioInterface() {
        return this.hasScreenInterface() ||
            typeof _get(this.getSupportedInterfaces(), 'AudioPlayer') !== 'undefined';
    }
    /**
     * Returns screen capability of request device
     * @return {boolean}
     */
    hasScreenInterface() {
        return this.hasDisplayInterface() || this.hasAPLInterface();
    }
    /**
     * Returns video capability of request device
     * @return {boolean}
     */
    hasVideoInterface() {
        return typeof _get(this.getSupportedInterfaces(), 'VideoApp') !== 'undefined';
    }
    isNewSession() {
        return _get(this, 'session.new', true);
    }
    setLocale(locale) {
        if (_get(this, `request.locale`)) {
            _set(this, 'request.locale', locale);
        }
        return this;
    }
    // Jovo Request -- SETTER
    setScreenInterface() {
        if (_get(this, 'context.System.device.supportedInterfaces')) {
            _set(this, 'context.System.device.supportedInterfaces', {
                'AudioPlayer': {},
                'Display': {
                    'templateVersion': '1.0',
                    'markupVersion': '1.0',
                },
                'VideoApp': {},
                'Alexa.Presentation.APL': {
                    'runtime': {
                        'maxVersion': '1.0'
                    }
                }
            });
        }
        return this;
    }
    setVideoInterface() {
        if (_get(this, 'context.System.device.supportedInterfaces')) {
            _set(this, 'context.System.device.supportedInterfaces', {
                'AudioPlayer': {},
                'Display': {
                    'templateVersion': '1.0',
                    'markupVersion': '1.0',
                },
                'VideoApp': {},
            });
        }
        return this;
    }
    setSessionAttributes(attributes) {
        if (this.getSessionAttributes()) {
            _set(this, 'session.attributes', attributes);
        }
        return this;
    }
    addSessionAttribute(key, value) {
        if (this.getSessionAttributes()) {
            _set(this, `session.attributes.${key}`, value);
        }
        return this;
    }
    setUserId(userId) {
        _set(this, 'session.user.userId', userId);
        _set(this, 'context.System.user.userId', userId);
        return this;
    }
    setAccessToken(accessToken) {
        _set(this, 'context.System.user.accessToken', accessToken);
        return this;
    }
    setNewSession(isNew) {
        if (typeof _get(this, 'session.new') !== 'undefined') {
            _set(this, 'session.new', isNew);
        }
        return this;
    }
    setTimestamp(timestamp) {
        if (_get(this, `request.timestamp`)) {
            _set(this, 'request.timestamp', timestamp);
        }
        return this;
    }
    setAudioInterface() {
        if (_get(this, 'context.System.device.supportedInterfaces')) {
            _set(this, 'context.System.device.supportedInterfaces', {
                'AudioPlayer': {},
            });
        }
        return this;
    }
    setState(state) {
        if (_get(this, 'session.attributes')) {
            _set(this, `session.attributes[${jovo_core_1.SessionConstants.STATE}]`, state);
        }
        return this;
    }
    addInput(key, value) {
        if (typeof value === 'string') {
            _set(this, `request.intent.slots.${key}`, {
                name: key,
                value
            });
        }
        else {
            _set(this, `request.intent.slots.${key}`, value);
        }
        return this;
    }
    toJSON() {
        // copy all fields from `this` to an empty object and return in
        return Object.assign({}, this);
    }
    // Alexa Request HELPER
    /**
     * Returns api endpoint based on user's locale settings
     * @return {String} endpoint url
     */
    getApiEndpoint() {
        return _get(this, 'context.System.apiEndpoint');
    }
    /**
     * Returns api access token
     * @return {String} endpoint url
     */
    getApiAccessToken() {
        return _get(this, 'context.System.apiAccessToken');
    }
    /**
     * Returns consent token
     * @return {string} constent token
     */
    getConsentToken() {
        return _get(this, 'context.System.user.permissions.consentToken');
    }
    /**
     * Returns device id
     * @return {string} device id
     */
    getDeviceId() {
        return _get(this, 'context.System.device.deviceId');
    }
    /**
     * Returns audio player token
     * @return {string}
     */
    getAudioPlayerToken() {
        return _get(this, 'context.AudioPlayer.token', _get(this, 'request.token'));
    }
    getRequestId() {
        return _get(this, 'request.requestId');
    }
    /**
     * Returns supported interfaces from device.
     * @public
     * @return {string} supportedInterfaces
     */
    getSupportedInterfaces() {
        return _get(this, 'context.System.device.supportedInterfaces');
    }
    /**
     * Returns audio capability of request device
     * @return {boolean}
     */
    hasAudioPlayerInterface() {
        return this.hasScreenInterface() ||
            typeof _get(this.getSupportedInterfaces(), 'AudioPlayer') !== 'undefined';
    }
    /**
     * Returns display capability of request device
     * @return {boolean}
     */
    hasDisplayInterface() {
        return typeof _get(this.getSupportedInterfaces(), 'Display') !== 'undefined';
    }
    hasAPLInterface() {
        return typeof _get(this.getSupportedInterfaces(), 'Alexa.Presentation.APL') !== 'undefined';
    }
    hasGeoLocationInterface() {
        return typeof _get(this.getSupportedInterfaces(), 'Geolocation') !== 'undefined';
    }
    getIntentName() {
        return _get(this, 'request.intent.name');
    }
    getSlots() {
        return _get(this, 'request.intent.slots');
    }
    getSlot(name) {
        return _get(this, `request.intent.slots.${name}`);
    }
    setSlots(slots) {
        _set(this, `request.intent.slots`, slots);
        return this;
    }
    setSlot(name, value) {
        _set(this, `request.intent.slots.${name}`, {
            name,
            value
        });
        return this;
    }
    setIntentName(intentName) {
        if (this.getIntentName()) {
            _set(this, 'request.intent.name', intentName);
        }
        return this;
    }
    // fromJSON is used to convert an serialized version
    // of the User to an instance of the class
    static fromJSON(json) {
        if (typeof json === 'string') {
            // if it's a string, parse it first
            return JSON.parse(json, AlexaRequest.reviver);
        }
        else {
            // create an instance of the User class
            const alexaRequest = Object.create(AlexaRequest.prototype);
            // copy all the fields from the json object
            return Object.assign(alexaRequest, json);
        }
    }
    // reviver can be passed as the second parameter to JSON.parse
    // to automatically call User.fromJSON on the resulting value.
    static reviver(key, value) {
        return key === "" ? AlexaRequest.fromJSON(value) : value;
    }
}
exports.AlexaRequest = AlexaRequest;
//# sourceMappingURL=AlexaRequest.js.map