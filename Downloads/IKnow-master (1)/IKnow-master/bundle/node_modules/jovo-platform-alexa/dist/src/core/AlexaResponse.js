"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jovo_core_1 = require("jovo-core");
const _get = require("lodash.get");
const _set = require("lodash.set");
/**
 * Thanks to @see http://choly.ca/post/typescript-json/
 */
class AlexaResponse {
    constructor() {
        this.version = '1.0';
        this.response = {
            shouldEndSession: true,
        };
        this.sessionAttributes = {};
    }
    getSessionData(path) {
        if (path) {
            return this.getSessionAttribute(path);
        }
        else {
            return this.getSessionAttributes();
        }
    }
    hasSessionData(name, value) {
        return this.hasSessionAttribute(name, value);
    }
    setSessionData(sessionData) {
        return this.setSessionAttributes(sessionData);
    }
    getSessionAttributes() {
        return _get(this, 'sessionAttributes');
    }
    setSessionAttributes(sessionData) {
        _set(this, 'sessionAttributes', sessionData);
        return this;
    }
    getSpeech() {
        if (!_get(this, 'response.outputSpeech.ssml')) {
            return;
        }
        return jovo_core_1.SpeechBuilder.removeSpeakTags(_get(this, 'response.outputSpeech.ssml'));
    }
    getReprompt() {
        if (!_get(this, 'response.outputSpeech.ssml')) {
            return;
        }
        return jovo_core_1.SpeechBuilder.removeSpeakTags(_get(this, 'response.reprompt.outputSpeech.ssml'));
    }
    getSpeechPlain() {
        const speech = this.getSpeech();
        if (!speech) {
            return;
        }
        return jovo_core_1.SpeechBuilder.removeSSML(speech);
    }
    getRepromptPlain() {
        const reprompt = this.getReprompt();
        if (!reprompt) {
            return;
        }
        return jovo_core_1.SpeechBuilder.removeSSML(reprompt);
    }
    getSessionAttribute(name) {
        return _get(this, `sessionAttributes.${name}`);
    }
    /**
     *
     * @param {string} name
     * @param {any} value
     * @return {boolean}
     */
    hasSessionAttribute(name, value) {
        if (!this.getSessionAttribute(name)) {
            return false;
        }
        if (typeof value !== 'undefined') {
            if (this.getSessionAttribute(name) !== value) {
                return false;
            }
        }
        return true;
    }
    hasState(state) {
        return this.hasSessionAttribute(jovo_core_1.SessionConstants.STATE, state);
    }
    hasSessionEnded() {
        return _get(this, 'response.shouldEndSession');
    }
    /**
     * Checks if response is a tell request
     * @param {string| string[]} speechText
     * @return {boolean}
     */
    isTell(speechText) {
        if (_get(this, 'response.shouldEndSession') === false) {
            return false;
        }
        if (speechText) {
            const ssml = _get(this, 'response.outputSpeech.ssml');
            if (Array.isArray(speechText)) {
                for (const speechTextElement of speechText) {
                    if (jovo_core_1.SpeechBuilder.toSSML(speechTextElement) === ssml) {
                        return true;
                    }
                }
                return false;
            }
            else {
                return ssml === jovo_core_1.SpeechBuilder.toSSML(speechText);
            }
        }
        return true;
    }
    isAsk(speechText, repromptText) {
        if (_get(this, 'response.shouldEndSession') === true) {
            return false;
        }
        if (speechText) {
            const ssml = _get(this, 'response.outputSpeech.ssml');
            if (Array.isArray(speechText)) {
                for (const speechTextElement of speechText) {
                    if (jovo_core_1.SpeechBuilder.toSSML(speechTextElement) === ssml) {
                        return true;
                    }
                }
                return false;
            }
            else {
                if (ssml !== jovo_core_1.SpeechBuilder.toSSML(speechText)) {
                    return false;
                }
            }
        }
        if (repromptText) {
            const ssml = _get(this, 'response.reprompt.outputSpeech.ssml');
            if (Array.isArray(repromptText)) {
                for (const speechTextElement of repromptText) {
                    if (jovo_core_1.SpeechBuilder.toSSML(speechTextElement) === ssml) {
                        return true;
                    }
                }
                return false;
            }
            else {
                if (ssml !== jovo_core_1.SpeechBuilder.toSSML(repromptText)) {
                    return false;
                }
            }
        }
        if (!_get(this, 'response.outputSpeech.ssml') ||
            !_get(this, 'response.outputSpeech.type')) {
            return false;
        }
        if (!_get(this, 'response.reprompt.outputSpeech.ssml') ||
            !_get(this, 'response.reprompt.outputSpeech.type')) {
            return false;
        }
        return true;
    }
    toJSON() {
        // copy all fields from `this` to an empty object and return in
        return Object.assign({}, this);
    }
    // fromJSON is used to convert an serialized version
    // of the User to an instance of the class
    static fromJSON(json) {
        if (typeof json === 'string') {
            // if it's a string, parse it first
            return JSON.parse(json, AlexaResponse.reviver);
        }
        else {
            // create an instance of the User class
            const alexaResponse = Object.create(AlexaResponse.prototype);
            // copy all the fields from the json object
            return Object.assign(alexaResponse, json);
        }
    }
    // reviver can be passed as the second parameter to JSON.parse
    // to automatically call User.fromJSON on the resulting value.
    static reviver(key, value) {
        return key === "" ? AlexaResponse.fromJSON(value) : value;
    }
}
exports.AlexaResponse = AlexaResponse;
//# sourceMappingURL=AlexaResponse.js.map