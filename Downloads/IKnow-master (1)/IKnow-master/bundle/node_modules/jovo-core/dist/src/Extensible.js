"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventEmitter = require("events");
const ActionSet_1 = require("./ActionSet");
const _merge = require("lodash.merge");
const _get = require("lodash.get");
const _isEqual = require("lodash.isequal");
const _cloneDeep = require("lodash.clonedeep");
const _transform = require("lodash.transform");
const Log_1 = require("./Log");
/**
 * Allows a class to use plugins
 */
class Extensible extends EventEmitter {
    constructor(config) {
        super();
        this.config = {
            enabled: true,
            plugin: {},
        };
        this.$plugins = new Map();
        this.setMaxListeners(0);
        if (config) {
            this.config = _merge(this.config, config);
        }
        this.actionSet = new ActionSet_1.ActionSet([], this);
    }
    /**
     * Adds plugin to base class
     * @param {Plugin} plugins
     * @returns {this}
     */
    use(...plugins) {
        plugins.forEach((plugin) => {
            const name = plugin.name || plugin.constructor.name;
            // needed to instantiate the object from a string
            const tmpConstructorArray = {
                [plugin.constructor.name]: plugin.constructor
            };
            if (plugin.config) {
                const emptyDefaultPluginObject = new tmpConstructorArray[plugin.constructor.name]();
                const pluginDefaultConfig = _cloneDeep(emptyDefaultPluginObject.config);
                const appConfig = _cloneDeep(this.config);
                const pluginAppConfig = {}; // tslint:disable-line
                Object.keys(pluginDefaultConfig).forEach((item) => {
                    pluginAppConfig[item] = _get(appConfig, `plugin.${name}.${item}`);
                });
                const pluginConstructorConfig = {}; // tslint:disable-line
                const constructorConfig = difference(plugin.config, pluginDefaultConfig);
                Object.keys(pluginDefaultConfig).forEach((item) => {
                    pluginConstructorConfig[item] = _get(constructorConfig, `${item}`);
                });
                plugin.config = _merge(pluginDefaultConfig, pluginAppConfig, constructorConfig);
                if (this.config.plugin && this.config.plugin[name]) {
                    this.config.plugin[name] = plugin.config;
                }
            }
            // remove existing plugin with the same name
            if (this.$plugins.get(name)) {
                this.$plugins.get(name).uninstall(this);
            }
            this.$plugins.set(name, plugin);
            plugin.install(this);
            if (this.constructor.name === 'App') {
                Log_1.Log.yellow().verbose(`Installed plugin: ${name} (${this.constructor.name})`);
                Log_1.Log.debug(`${JSON.stringify(plugin.config || {}, null, '\t')}`);
                Log_1.Log.debug();
            }
            this.emit('use', plugin);
        });
        return this;
    }
    /**
     * Removes all plugins from extensible object
     * Calls plugin's uninstall() method
     */
    removeAll() {
        this.$plugins.forEach((entry) => {
            entry.uninstall(this);
        });
        this.$plugins.clear();
    }
    /**
     * Removes plugin from plugins
     * @param {string} name
     */
    remove(name) {
        if (this.$plugins.get(name)) {
            this.$plugins.get(name).uninstall(this);
            this.$plugins.delete(name);
            Log_1.Log.verbose(`Removed plugin: ${name}`);
        }
    }
    /**
     * Return or initialize middleware
     * @param {string} name
     * @returns {Middleware}
     */
    middleware(name) {
        if (!this.actionSet.get(name)) {
            return this.actionSet.create(name, this);
        }
        return this.actionSet.get(name);
    }
    /**
     * Check for middleware with given name
     * @param {string} name
     * @return {boolean}
     */
    hasMiddleware(name) {
        return typeof this.actionSet.get(name) !== 'undefined';
    }
}
exports.Extensible = Extensible;
/**
 * @see https://gist.github.com/Yimiprod/7ee176597fef230d1451
 * Deep diff between two object, using lodash
 * @param  {any} object Object compared
 * @param  {any} base   Object to compare with
 * @return {any}        Return a new object who represent the diff
 */
// tslint:disable-next-line
function difference(object, base) {
    // tslint:disable-next-line
    function changes(object, base) {
        // tslint:disable-next-line
        return _transform(object, (result, value, key) => {
            if (!_isEqual(value, base[key])) {
                result[key] = (typeof value === 'object' && typeof base[key] === 'object') ? changes(value, base[key]) : value;
            }
        });
    }
    return changes(object, base);
}
//# sourceMappingURL=Extensible.js.map