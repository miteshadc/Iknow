"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const fs = require("fs");
const _merge = require("lodash.merge");
const _get = require("lodash.get");
const crypto = require("crypto");
const util = require("util");
const path = require("path");
const fsunlink = util.promisify(fs.unlink);
const fsexists = util.promisify(fs.exists);
class Conversation {
    constructor(testSuite, config) {
        this.sessionData = {};
        this.config = {
            userId: randomUserId(),
            locale: 'en-US',
            defaultDbDirectory: './db/tests/',
            deleteDbOnSessionEnded: true,
            httpOptions: {
                host: 'localhost',
                port: process.env.JOVO_PORT || 3000,
                path: '/webhook',
                method: 'POST',
                headers: {
                    'accept': 'application/json',
                    'content-type': 'application/json',
                    'jovo-test': 'true'
                },
            },
        };
        this.testSuite = testSuite;
        if (config) {
            this.config = _merge(this.config, config);
        }
    }
    applyToRequest(req) {
        req.setUserId(this.config.userId || randomUserId());
        req.setTimestamp(new Date().toISOString());
        if (this.config.locale) {
            req.setLocale(this.config.locale);
        }
    }
    async send(req) {
        this.applyToRequest(req);
        if (req.isNewSession()) {
            this.sessionData = {};
        }
        else if (Object.keys(this.sessionData).length > 0) {
            req.setSessionData(this.sessionData);
        }
        const postData = JSON.stringify(req.toJSON());
        try {
            const response = await Conversation.httpRequest(postData, this.config.httpOptions || {});
            const jovoResponse = this.testSuite.responseBuilder.create(JSON.parse(response));
            this.sessionData = jovoResponse.getSessionData() || {};
            if (this.config.deleteDbOnSessionEnded === true && jovoResponse.hasSessionEnded()) {
                // this.clearDb();
            }
            return jovoResponse;
        }
        catch (e) {
            throw e;
        }
    }
    clearSession() {
        this.sessionData = {};
    }
    async reset() {
        this.clearSession();
        await this.clearDb();
    }
    async clearDb() {
        const pathToDb = path.join(this.config.defaultDbDirectory, this.config.userId + '.json');
        const exists = await fsexists(pathToDb);
        if (!exists) {
            throw new Error(`Can't find ${pathToDb}`);
        }
        await fsunlink(pathToDb);
    }
    static httpRequest(postData, options) {
        return new Promise((resolve, reject) => {
            const request = http.request(options, (res) => {
                res.setEncoding('utf8');
                let result = '';
                res.on('data', (data) => {
                    result += data;
                });
                res.on('end', () => {
                    resolve(result);
                });
            }).on('error', (e) => {
                if (_get(e, 'code') === 'ECONNREFUSED') {
                    console.log();
                    console.log('Your server must be running for your tests to work.');
                    console.log();
                    console.log(e);
                    console.log();
                }
                reject(e);
            });
            request.write(postData);
            request.end();
        });
    }
}
exports.Conversation = Conversation;
function randomUserId() {
    return Math.random().toString(36).substring(7);
}
function projectUserId() {
    return `testuser-${crypto.createHash('md5').update(__dirname).digest("hex")}`;
}
//# sourceMappingURL=Conversation.js.map