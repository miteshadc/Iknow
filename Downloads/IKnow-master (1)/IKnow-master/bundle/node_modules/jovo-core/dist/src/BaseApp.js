"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Extensible_1 = require("./Extensible");
const ActionSet_1 = require("./ActionSet");
const Log_1 = require("./Log");
const JovoError_1 = require("./errors/JovoError");
process.on('unhandledRejection', (reason, p) => {
    console.log('unhandledRejection');
    console.log(p);
    console.log(reason.stack);
    console.log(reason);
});
process.on('uncaughtException', (err) => {
    JovoError_1.JovoError.printError(err);
});
// @ts-ignore
process.env.JOVO_LOG_LEVEL = Log_1.LogLevel.INFO;
class BaseApp extends Extensible_1.Extensible {
    constructor(config) {
        super(config);
        this.initialized = false;
        this.config = {};
        this.$platform = new Map();
        this.$cms = {}; // tslint:disable-line
        this.$data = {};
        this.actionSet = new ActionSet_1.ActionSet([
            'setup',
            'request',
            'platform.init',
            'platform.nlu',
            'nlu',
            'user.load',
            'router',
            'handler',
            'user.save',
            'platform.output',
            'response',
            'fail'
        ], this);
        if (process.env.NODE_ENV !== 'UNIT_TEST') {
            process.on('exit', () => {
                this.emit('exit');
            });
            // catch ctrl+c event and exit normally
            process.on('SIGINT', () => {
                process.exit(2);
            });
        }
    }
    /**
     * Initialize setup middleware
     * @param {Function} callback
     */
    setUp(callback) {
        this.middleware('setup').use(callback);
    }
    /**
     * Is called on exit
     * IMPORTANT: Must have synchronous code only
     * @param {Function} callback
     */
    tearDown(callback) {
        this.on('exit', (jovo) => {
            callback(jovo);
        });
    }
    getPlatformByName(name) {
        return this.$platform.get(name);
    }
    initWebhook() {
        this.emit('webhook.init');
    }
    async handle(host) {
        const handleRequest = {
            app: this,
            host,
            jovo: undefined
        };
        try {
            Log_1.Log.verbose(Log_1.Log.header('Start request', 'framework'));
            // initialize on first call only
            if (!this.initialized) {
                await this.middleware('setup').run(handleRequest);
                this.initialized = true;
            }
            await this.middleware('request').run(handleRequest);
            await this.middleware('platform.init').run(handleRequest);
            if (!handleRequest.jovo) {
                throw new JovoError_1.JovoError(`Can't handle request object.`, 'ERR_NO_MATCHING_PLATFORM', 'jovo-core', undefined, 'Please add an integration that handles that type of request.');
            }
            Log_1.Log.verbose(Log_1.Log.header('After init ', 'framework'));
            Log_1.Log.yellow().verbose(`this.\$${handleRequest.jovo.constructor.name.substr(0, 1).toLowerCase()}${handleRequest.jovo.constructor.name.substr(1)} initialized`);
            Log_1.Log.yellow().verbose(`this.$type: ${JSON.stringify(handleRequest.jovo.$type)}`);
            Log_1.Log.yellow().verbose(`this.$session.$data : ${JSON.stringify(handleRequest.jovo.$session.$data)}`);
            Log_1.Log.verbose();
            await this.middleware('platform.nlu').run(handleRequest);
            await this.middleware('nlu').run(handleRequest);
            Log_1.Log.verbose(Log_1.Log.header('After nlu ', 'framework'));
            Log_1.Log.yellow().verbose(`this.$nlu : ${JSON.stringify(handleRequest.jovo.$nlu)}`);
            Log_1.Log.yellow().verbose(`this.$inputs : ${JSON.stringify(handleRequest.jovo.$inputs)}`);
            await this.middleware('user.load').run(handleRequest);
            await this.middleware('router').run(handleRequest);
            await this.middleware('handler').run(handleRequest);
            await this.middleware('user.save').run(handleRequest);
            Log_1.Log.white().verbose(Log_1.Log.header(`Output object: this.$output`, 'framework'));
            Log_1.Log.yellow().verbose(JSON.stringify(handleRequest.jovo.$output, null, '\t'));
            await this.middleware('platform.output').run(handleRequest);
            Log_1.Log.verbose(Log_1.Log.header('Response ', 'framework'));
            await this.middleware('response').run(handleRequest);
        }
        catch (e) {
            JovoError_1.JovoError.printError(e);
            if (handleRequest.jovo) {
                Log_1.Log.error();
                Log_1.Log.error('Request details:');
                Log_1.Log.error(`this.\$${handleRequest.jovo.constructor.name.substr(0, 1).toLowerCase()}${handleRequest.jovo.constructor.name.substr(1)} initialized`);
                Log_1.Log.error(`this.$type: ${JSON.stringify(handleRequest.jovo.$type)}`);
                Log_1.Log.error(`this.$session.$data : ${JSON.stringify(handleRequest.jovo.$session.$data)}`);
                Log_1.Log.error(`this.$nlu : ${JSON.stringify(handleRequest.jovo.$nlu)}`);
                Log_1.Log.error(`this.$inputs : ${JSON.stringify(handleRequest.jovo.$inputs)}`);
                Log_1.Log.error();
            }
            handleRequest.error = e;
            Log_1.Log.red().error(Log_1.Log.header());
            await this.middleware('fail').run(handleRequest);
            handleRequest.host.fail(e);
        }
    }
    onRequest(callback) {
        this.on('request', (handleRequest) => {
            callback(handleRequest);
        });
    }
    onResponse(callback) {
        this.on('response', (handleRequest) => {
            callback(handleRequest);
        });
    }
    onError(callback) {
        this.on('fail', (handleRequest) => {
            callback(handleRequest);
        });
    }
    onFail(callback) {
        this.on('fail', (handleRequest) => {
            callback(handleRequest);
        });
    }
    install(extensible) {
    }
    uninstall(extensible) {
    }
}
exports.BaseApp = BaseApp;
//# sourceMappingURL=BaseApp.js.map