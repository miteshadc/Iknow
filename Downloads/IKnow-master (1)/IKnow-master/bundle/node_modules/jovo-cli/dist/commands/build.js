#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const JovoRenderer_1 = require("../utils/JovoRenderer");
const Listr = require("listr");
const DeployTargets = require("../utils/DeployTargets");
const Platforms = require("../utils/Platforms");
const Utils_1 = require("../utils/Utils");
const Prompts_1 = require("../utils/Prompts");
const Validator_1 = require("../utils/Validator");
const jovo_cli_core_1 = require("jovo-cli-core");
const tasks_1 = require("./tasks");
const subHeadline = require('chalk').white.dim;
const project = jovo_cli_core_1.getProject();
module.exports = (vorpal) => {
    let DEBUG = false;
    const vorpalInstance = vorpal
        .command('build')
        .description('Build platform-specific language models based on jovo models folder.')
        .option('-l, --locale <locale>', 'Locale of the language model.\n\t\t\t\t<en-US|de-DE|etc> Default: en-US')
        .option('-p, --platform <platform>', `Platform \n\t\t\t\t <${Platforms.getAllAvailable().join('|')}>`)
        .option('-d, --deploy', 'Runs deploy after build')
        .option('-r, --reverse', 'Builds Jovo language model from platfrom specific language model')
        .option('-t, --target <target>', `Target of build \n\t\t\t\t${DeployTargets.getDeployExampleText()}`)
        .option('-s, --src <src>', 'Path to source files \n\t\t\t\t Default: <project directory>')
        .option('--stage <stage>', 'Takes configuration from <stage>')
        .option('--endpoint <endpoint>', 'Type of endpoint \n\t\t\t\t<jovo-webhook|bst-proxy|ngrok|none> - Default: jovo-webhook')
        .option('--overwrite', 'Forces overwrite of existing project for reverse build')
        .option('--ignore <task>', 'Task which should be ignored \n\t\t\t\t<model-validation|none> - Default: none')
        .option('\n');
    Platforms.addCliOptions('build', vorpalInstance);
    Utils_1.addBaseCliOptions(vorpalInstance);
    vorpalInstance
        .validate((args) => {
        if (!Platforms.validateCliOptions('build', args)) {
            return false;
        }
        return Validator_1.isValidLocale(args.options.locale) &&
            Validator_1.isValidPlatform(args.options.platform);
    })
        .action(async (args) => {
        try {
            DEBUG = args.options.debug ? true : false;
            let answers;
            console.log(' jovo build:  Create and update platform specific files in /platforms folder');
            console.log(subHeadline('   >> Learn more: https://jovo.tech/docs/cli/build'));
            await project.init();
            const tasks = new Listr([], {
                renderer: JovoRenderer_1.JovoCliRenderer,
                collapse: false,
                separateTopTasks: true,
            });
            try {
                project.getConfig(args.options.stage);
            }
            catch (e) {
                console.log(`\n\n Could not load ${project.getConfigFileName()}. \n\n`);
                if (DEBUG === true) {
                    console.error(e);
                }
                return Promise.resolve();
            }
            const types = [];
            if (args.options.platform) {
                types.push(args.options.platform);
            }
            else {
                types.push.apply(types, Platforms.getAll(args.platform, args.options.stage));
            }
            const config = {
                locales: project.getLocales(args.options.locale),
                types,
                projectId: args.options['project-id'] || project.getConfigParameter('googleAction.dialogflow.projectId', args.options.stage),
                endpoint: args.options.endpoint || jovo_cli_core_1.DEFAULT_ENDPOINT,
                target: args.options.target || jovo_cli_core_1.DEFAULT_TARGET,
                src: args.options.src || project.getConfigParameter('src', args.options.stage) || project.getProjectPath(),
                stage: project.getStage(args.options.stage),
                debug: DEBUG,
                frameworkVersion: project.frameworkVersion,
                ignoreTasks: (args.options.ignore || '').split(',').map((item) => item.trim()),
            };
            if (!project.hasConfigFile()) {
                if (project.frameworkVersion === 1) {
                    if (config.types && config.types.length === 0) {
                        answers = await Prompts_1.promptForInit('To use this command, please first initialize at least one platform with jovo init. You can also choose one here:');
                        config.types = [answers.platform];
                    }
                }
                else {
                    console.error(`The "${project.getConfigPath()}" file is missing or invalid!`);
                    return;
                }
            }
            if (config.types.length !== 1 && args.options.reverse) {
                answers = await Prompts_1.promptForInit('Please select the platform you want to reverse build from:');
                config.types = [answers.platform];
            }
            for (const type of config.types) {
                const platform = Platforms.get(type);
                _.merge(config, platform.getPlatformConfigValues(project, args.options));
                if (args.options.reverse) {
                    const platform = Platforms.get(type);
                    config.locales = platform.getLocales(args.options.locale);
                    if (args.options.overwrite) {
                        config.reverse = true;
                    }
                    else if (project.hasModelFiles(config.locales)) {
                        answers = await Prompts_1.promptOverwriteReverseBuild();
                        if (answers.promptOverwriteReverseBuild === Prompts_1.ANSWER_CANCEL) {
                            return;
                        }
                        else {
                            config.reverse = answers.promptOverwriteReverseBuild;
                        }
                    }
                }
            }
            if (!project.hasConfigFile() && !args.options.reverse) {
                tasks.add(tasks_1.initTask());
            }
            if (args.options.reverse) {
                tasks.add({
                    title: 'Building language model platform model',
                    task: (ctx) => tasks_1.buildReverseTask(ctx),
                });
            }
            else {
                tasks_1.buildTask(config).forEach((t) => tasks.add(t));
                if (args.options.deploy) {
                    tasks.add({
                        title: 'Deploying',
                        task: (ctx) => {
                            return new Listr(tasks_1.deployTask(ctx));
                        },
                    });
                }
            }
            return tasks.run(config).then(() => {
                console.log();
                console.log('  Build completed.');
                console.log();
            }).catch((err) => {
                if (err.show) {
                    err.show();
                }
                else {
                    console.error(err.message);
                }
                if (DEBUG === true) {
                    if (err.context) {
                        console.error(err.context);
                    }
                }
                process.exit(1);
            });
        }
        catch (err) {
            console.error('There was a problem:');
            console.error(err);
            process.exit(1);
        }
    });
};
//# sourceMappingURL=build.js.map