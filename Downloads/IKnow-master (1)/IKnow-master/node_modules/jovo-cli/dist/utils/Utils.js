"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const fs = require("fs");
const path_1 = require("path");
const logSymbols = require("log-symbols");
const figures = require("figures");
const elegantSpinner = require("elegant-spinner");
const latestVersion = require("latest-version");
const { promisify } = require('util');
const readFileAsync = promisify(fs.readFile);
const project = require('jovo-cli-core').getProject();
const pointer = chalk.yellow(figures.pointer);
function isDefined(x) {
    return x !== null && x !== undefined;
}
exports.isDefined = isDefined;
function getSymbol(task, options) {
    if (!task.spinner) {
        task.spinner = elegantSpinner();
    }
    if (task.isPending()) {
        return options.showSubtasks !== false && task.subtasks.length > 0 ?
            pointer
            :
                chalk.yellow(task.spinner());
    }
    if (task.isCompleted()) {
        return logSymbols.success;
    }
    if (task.hasFailed()) {
        return task.subtasks.length > 0 ? pointer : logSymbols.error;
    }
    if (task.isSkipped()) {
        return logSymbols.success;
    }
    return ' ';
}
exports.getSymbol = getSymbol;
function deleteFolderRecursive(filepath) {
    if (fs.existsSync(filepath)) {
        fs.readdirSync(filepath).forEach((file, index) => {
            const curPath = path_1.join(filepath, file);
            if (fs.lstatSync(curPath).isDirectory()) {
                exports.deleteFolderRecursive(curPath);
            }
            else {
                fs.unlinkSync(curPath);
            }
        });
        fs.rmdirSync(filepath);
    }
}
exports.deleteFolderRecursive = deleteFolderRecursive;
function addBaseCliOptions(vorpalInstance) {
    vorpalInstance
        .option('--debug', 'Displays additional debugging information');
}
exports.addBaseCliOptions = addBaseCliOptions;
async function getPackages(packageRegex) {
    const projectPath = project.getProjectPath();
    const packagePath = path_1.join(projectPath, 'package-lock.json');
    let content;
    try {
        content = await readFileAsync(packagePath);
    }
    catch (e) {
        return {};
    }
    const packageFile = JSON.parse(content);
    const packages = {};
    Object.keys(packageFile.dependencies).forEach((packageName) => {
        if (packageRegex && !packageName.match(packageRegex)) {
            return;
        }
        packages[packageName] = packageFile.dependencies[packageName].version;
    });
    return packages;
}
exports.getPackages = getPackages;
async function getPackageVersionsNpm(packageRegex) {
    const packages = await getPackages(packageRegex);
    const queryPromises = {};
    for (const packageName of Object.keys(packages)) {
        queryPromises[packageName] = latestVersion(packageName);
    }
    const returnPackages = {};
    for (const packageName of Object.keys(packages)) {
        returnPackages[packageName] = {
            local: packages[packageName],
            npm: await queryPromises[packageName],
        };
    }
    return returnPackages;
}
exports.getPackageVersionsNpm = getPackageVersionsNpm;
function shouldDisplayUpdateMessage(hours) {
    const jovoConfig = project.loadJovoConfig();
    if (!jovoConfig.hasOwnProperty('timeLastUpdateMessage')) {
        return true;
    }
    const nextDisplayTime = new Date(jovoConfig.timeLastUpdateMessage).getTime() + (1000 * 60 * 60 * hours);
    if (new Date().getTime() < nextDisplayTime) {
        return false;
    }
    return true;
}
exports.shouldDisplayUpdateMessage = shouldDisplayUpdateMessage;
function setUpdateMessageDisplayed() {
    const jovoConfig = project.loadJovoConfig();
    jovoConfig.timeLastUpdateMessage = new Date().toISOString();
    project.saveJovoConfig(jovoConfig);
}
exports.setUpdateMessageDisplayed = setUpdateMessageDisplayed;
//# sourceMappingURL=Utils.js.map