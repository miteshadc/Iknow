"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bespoke_client_1 = require("./bespoke-client");
const lambda_server_1 = require("./lambda-server");
const bst_config_1 = require("./bst-config");
const global_1 = require("../core/global");
const bst_config_2 = require("./bst-config");
const function_server_1 = require("./function-server");
const logging_helper_1 = require("../core/logging-helper");
var ProxyType;
(function (ProxyType) {
    ProxyType[ProxyType["GOOGLE_CLOUD_FUNCTION"] = 0] = "GOOGLE_CLOUD_FUNCTION";
    ProxyType[ProxyType["HTTP"] = 1] = "HTTP";
    ProxyType[ProxyType["LAMBDA"] = 2] = "LAMBDA";
})(ProxyType = exports.ProxyType || (exports.ProxyType = {}));
const DefaultLambdaPort = 10000;
class BSTProxy {
    constructor(proxyType) {
        this.proxyType = proxyType;
        this.bespokenClient = null;
        this.functionServer = null;
        this.lambdaServer = null;
        this.isSecure = false;
        this.bespokenHost = "proxy.bespoken.tools";
        this.bespokenPort = 5000;
        this.httpDomain = "localhost";
    }
    static http(targetPort) {
        let tool = new BSTProxy(ProxyType.HTTP);
        tool.httpPort = targetPort;
        return tool;
    }
    static lambda(lambdaFile, functionName) {
        let tool = new BSTProxy(ProxyType.LAMBDA);
        tool.functionFile = lambdaFile;
        tool.functionName = functionName;
        tool.httpPort = DefaultLambdaPort;
        return tool;
    }
    static cloudFunction(functionFile, functionName) {
        let tool = new BSTProxy(ProxyType.GOOGLE_CLOUD_FUNCTION);
        tool.functionFile = functionFile;
        tool.functionName = functionName;
        tool.httpPort = DefaultLambdaPort;
        return tool;
    }
    bespokenServer(host, port) {
        this.bespokenHost = host;
        this.bespokenPort = port;
        return this;
    }
    targetDomain(host) {
        this.httpDomain = host;
        return this;
    }
    secretKey(secretKey) {
        this.proxySecretKey = secretKey;
        return this;
    }
    activateSecurity() {
        this.isSecure = true;
    }
    port(port) {
        this.httpPort = port;
        return this;
    }
    startWithConfig(onStarted) {
        this.bespokenClient = new bespoke_client_1.BespokeClient(this.proxySecretKey, this.bespokenHost, this.bespokenPort, this.httpDomain, this.httpPort, this.isSecure ? this.proxySecretKey : undefined);
        let callbackCountDown = 1;
        const callback = function () {
            callbackCountDown--;
            if (callbackCountDown === 0 && onStarted !== undefined) {
                onStarted();
            }
        };
        this.bespokenClient.onConnect = callback;
        this.bespokenClient.connect();
        if (this.proxyType === ProxyType.LAMBDA) {
            callbackCountDown++;
            this.lambdaServer = new lambda_server_1.LambdaServer(this.functionFile, this.httpPort, false, this.functionName);
            this.lambdaServer.start(callback);
        }
        if (this.proxyType === ProxyType.GOOGLE_CLOUD_FUNCTION) {
            callbackCountDown++;
            this.functionServer = new function_server_1.FunctionServer(this.functionFile, this.functionName, this.httpPort);
            this.functionServer.start(callback);
        }
        return this;
    }
    start(onStarted) {
        const self = this;
        if (global_1.Global.config()) {
            bst_config_1.BSTProcess.run(this.httpPort, this.proxyType, process.pid);
            this.proxySecretKey = global_1.Global.config().secretKey();
            this.startWithConfig(onStarted);
        }
        else {
            if (!this.proxySecretKey) {
                bst_config_2.BSTConfig.load().then((config) => {
                    self.proxySecretKey = config.secretKey();
                    self.startWithConfig(onStarted);
                    logging_helper_1.LoggingHelper.initialize(false);
                });
                return;
            }
            self.startWithConfig(onStarted);
            logging_helper_1.LoggingHelper.initialize(false);
        }
    }
    stop(onStopped) {
        if (this.bespokenClient !== null) {
            this.bespokenClient.shutdown();
        }
        if (this.lambdaServer !== null) {
            this.lambdaServer.stop(onStopped);
        }
        else if (this.functionServer !== null) {
            this.functionServer.stop(onStopped);
        }
        else {
            if (onStopped !== undefined && onStopped !== null) {
                onStopped();
            }
        }
    }
}
exports.BSTProxy = BSTProxy;
//# sourceMappingURL=bst-proxy.js.map