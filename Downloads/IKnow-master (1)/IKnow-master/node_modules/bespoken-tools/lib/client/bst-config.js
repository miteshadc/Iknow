"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const logging_helper_1 = require("../core/logging-helper");
const lambda_config_1 = require("./lambda-config");
const source_name_generator_1 = require("../external/source-name-generator");
const spokes_1 = require("../external/spokes");
const Logger = "CONFIG";
const BSTDirectoryName = ".bst";
class BSTConfig {
    constructor() {
        this.configuration = null;
        this.process = null;
    }
    static load() {
        return __awaiter(this, void 0, void 0, function* () {
            yield BSTConfig.bootstrapIfNeeded();
            let data = fs.readFileSync(BSTConfig.configPath());
            let config = JSON.parse(data.toString());
            let bstConfig = new BSTConfig();
            bstConfig.loadFromJSON(config);
            return bstConfig;
        });
    }
    save() {
        BSTConfig.saveConfig(this.configuration);
    }
    static getBstVersion() {
        const packageInfo = require("../../package.json");
        return packageInfo.version;
    }
    sourceID() {
        return this.configuration.sourceID;
    }
    secretKey() {
        return this.configuration.secretKey;
    }
    applicationID() {
        return this.configuration.applicationID;
    }
    updateApplicationID(applicationID) {
        this.configuration.applicationID = applicationID;
        this.commit();
    }
    updateVirtualDeviceToken(virtualDeviceToken) {
        this.configuration.virtualDeviceToken = virtualDeviceToken;
        this.commit();
    }
    deleteSession() {
        if (fs.existsSync(BSTConfig.sessionPath())) {
            fs.unlinkSync(BSTConfig.sessionPath());
        }
    }
    saveSession(session) {
        const sessionBuffer = new Buffer(JSON.stringify(session, null, 4) + "\n");
        fs.writeFileSync(BSTConfig.sessionPath(), sessionBuffer);
    }
    loadSession() {
        if (!fs.existsSync(BSTConfig.sessionPath())) {
            return null;
        }
        const data = fs.readFileSync(BSTConfig.sessionPath());
        return JSON.parse(data.toString());
    }
    virtualDeviceToken() {
        return this.configuration.virtualDeviceToken;
    }
    commit() {
        let configBuffer = new Buffer(JSON.stringify(this.configuration, null, 4) + "\n");
        fs.writeFileSync(BSTConfig.configPath(), configBuffer);
    }
    loadFromJSON(config) {
        this.configuration = config;
    }
    static configDirectory() {
        return getUserHome() + "/" + BSTDirectoryName;
    }
    static configPath() {
        return BSTConfig.configDirectory() + "/config";
    }
    static sessionPath() {
        return BSTConfig.configDirectory() + "/session";
    }
    static bootstrapIfNeeded() {
        return __awaiter(this, void 0, void 0, function* () {
            let directory = BSTConfig.configDirectory();
            if (!fs.existsSync(directory)) {
                fs.mkdirSync(directory);
            }
            if (!fs.existsSync(BSTConfig.configPath())) {
                logging_helper_1.LoggingHelper.info(Logger, "No configuration. Creating one: " + BSTConfig.configPath());
                let configJSON = yield BSTConfig.createConfig();
                BSTConfig.saveConfig(configJSON);
            }
            else {
                let data = fs.readFileSync(BSTConfig.configPath());
                let config = JSON.parse(data.toString());
                if (!config.sourceID || !config.version) {
                    yield BSTConfig.updateConfig(config);
                }
            }
        });
    }
    static updateConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const previousKey = config.nodeID || config.secretKey;
            const generatedConfig = yield BSTConfig.createConfig(previousKey, config.sourceID);
            config.sourceID = generatedConfig.sourceID;
            config.secretKey = generatedConfig.secretKey;
            config.version = generatedConfig.version;
            delete config.nodeID;
            BSTConfig.saveConfig(config);
        });
    }
    static saveConfig(config) {
        let configBuffer = new Buffer(JSON.stringify(config, null, 4) + "\n");
        fs.writeFileSync(BSTConfig.configPath(), configBuffer);
    }
    static createConfig(nodeID, sourceID) {
        return __awaiter(this, void 0, void 0, function* () {
            const lambdaConfig = lambda_config_1.LambdaConfig.defaultConfig().lambdaDeploy;
            const pipeInfo = yield BSTConfig.createExternalResources(nodeID, sourceID);
            return {
                "sourceID": pipeInfo.endPoint.name,
                "secretKey": pipeInfo.uuid,
                "lambdaDeploy": lambdaConfig,
                "version": this.getBstVersion(),
            };
        });
    }
    static createSpokesPipe(id, secretKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const spokesClient = new spokes_1.SpokesClient(id, secretKey);
            const isUUIDUnassigned = yield spokesClient.verifyUUIDisNew();
            if (isUUIDUnassigned) {
                return spokesClient.createPipe();
            }
            return {
                endPoint: {
                    name: id,
                },
                uuid: secretKey,
            };
        });
    }
    static createSource(secretKey, sourceID) {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceNameGenerator = new source_name_generator_1.SourceNameGenerator();
            let id;
            let key;
            if (!secretKey) {
                const generatedKey = yield sourceNameGenerator.callService();
                id = generatedKey.id;
                key = generatedKey.secretKey;
            }
            if (secretKey && !sourceID) {
                const generatedKey = yield sourceNameGenerator.callService();
                id = generatedKey.id;
                key = secretKey;
            }
            if (sourceID && secretKey) {
                id = sourceID;
                key = secretKey;
            }
            try {
                yield sourceNameGenerator.createDashboardSource(id, key);
            }
            catch (e) {
                if (e.statusCode !== 403) {
                    throw (e);
                }
            }
            return {
                id,
                key,
            };
        });
    }
    static createExternalResources(secretKey, sourceID) {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceData = yield this.createSource(secretKey, sourceID);
            const pipe = yield this.createSpokesPipe(sourceData.id, sourceData.key);
            return pipe;
        });
    }
}
exports.BSTConfig = BSTConfig;
class BSTProcess {
    constructor() { }
    static running() {
        let process = null;
        if (fs.existsSync(BSTProcess.processPath())) {
            let data = fs.readFileSync(BSTProcess.processPath());
            let json = JSON.parse(data.toString());
            if (BSTProcess.isRunning(json.pid)) {
                process = new BSTProcess();
                process.loadJSON(json);
            }
        }
        return process;
    }
    static isRunning(pid) {
        try {
            process.kill(pid, 0);
            return true;
        }
        catch (e) {
            return e.code === "EPERM";
        }
    }
    static processPath() {
        return getUserHome() + "/" + BSTDirectoryName + "/process";
    }
    static run(port, proxyType, pid) {
        let process = new BSTProcess();
        process.port = port;
        process.proxyType = proxyType;
        process.pid = pid;
        let json = process.json();
        let jsonBuffer = new Buffer(JSON.stringify(json, undefined, 4) + "\n");
        fs.writeFileSync(BSTProcess.processPath(), jsonBuffer);
        return process;
    }
    kill() {
        try {
            process.kill(this.pid, "SIGKILL");
            return true;
        }
        catch (e) {
            console.error("Error killing process[" + this.pid + "] Message: " + e.message);
            return false;
        }
    }
    loadJSON(json) {
        this.port = json.port;
        this.proxyType = json.proxyType;
        this.pid = json.pid;
    }
    json() {
        return {
            "port": this.port,
            "type": this.proxyType,
            "pid": this.pid
        };
    }
}
exports.BSTProcess = BSTProcess;
function getUserHome() {
    return process.env[(process.platform === "win32") ? "USERPROFILE" : "HOME"];
}
//# sourceMappingURL=bst-config.js.map