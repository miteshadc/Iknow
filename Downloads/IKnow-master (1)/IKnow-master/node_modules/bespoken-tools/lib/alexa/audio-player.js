"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const service_request_1 = require("./service-request");
const events_1 = require("events");
const audio_item_1 = require("./audio-item");
var AudioPlayerActivity;
(function (AudioPlayerActivity) {
    AudioPlayerActivity[AudioPlayerActivity["BUFFER_UNDERRUN"] = 0] = "BUFFER_UNDERRUN";
    AudioPlayerActivity[AudioPlayerActivity["FINISHED"] = 1] = "FINISHED";
    AudioPlayerActivity[AudioPlayerActivity["IDLE"] = 2] = "IDLE";
    AudioPlayerActivity[AudioPlayerActivity["PLAYING"] = 3] = "PLAYING";
    AudioPlayerActivity[AudioPlayerActivity["PAUSED"] = 4] = "PAUSED";
    AudioPlayerActivity[AudioPlayerActivity["STOPPED"] = 5] = "STOPPED";
})(AudioPlayerActivity = exports.AudioPlayerActivity || (exports.AudioPlayerActivity = {}));
class AudioPlayer {
    constructor(alexa) {
        this.alexa = alexa;
        this._emitter = null;
        this._playing = null;
        this._queue = [];
        this._activity = null;
        this._suspended = false;
        this._activity = AudioPlayerActivity.IDLE;
        this._emitter = new events_1.EventEmitter();
    }
    enqueue(audioItem, playBehavior) {
        if (playBehavior === AudioPlayer.PlayBehaviorEnqueue) {
            this._queue.push(audioItem);
        }
        else if (playBehavior === AudioPlayer.PlayBehaviorReplaceAll) {
            if (this.isPlaying()) {
                this.playbackStopped();
            }
            this._queue = [];
            this._queue.push(audioItem);
        }
        else if (playBehavior === AudioPlayer.PlayBehaviorReplaceEnqueued) {
            this._queue = [];
            this._queue.push(audioItem);
        }
        if (!this.isPlaying()) {
            this.playNext();
        }
    }
    activity() {
        return this._activity;
    }
    playNext() {
        if (this._queue.length === 0) {
            return;
        }
        this._playing = this.dequeue();
        if (this._playing.stream.url.startsWith("http:")) {
            this.alexa.sessionEnded(service_request_1.SessionEndedReason.ERROR, {
                type: "INVALID_RESPONSE",
                message: "The URL specified in the Play directive must be HTTPS"
            });
        }
        else {
            this.playbackStarted();
        }
    }
    suspend() {
        this._suspended = true;
        this.playbackStopped();
    }
    suspended() {
        return this._suspended;
    }
    playbackOffset(offset) {
        if (this.isPlaying()) {
            this.playing().stream.offsetInMilliseconds = offset;
        }
    }
    on(audioPlayerRequest, listener) {
        this._emitter.on(audioPlayerRequest, listener);
    }
    once(audioPlayerRequest, listener) {
        this._emitter.once(audioPlayerRequest, listener);
    }
    resume() {
        this._suspended = false;
        this.playbackStarted();
    }
    playbackNearlyFinished(callback) {
        this.audioPlayerRequest(service_request_1.RequestType.AudioPlayerPlaybackNearlyFinished, callback);
    }
    playbackFinished(callback) {
        this._activity = AudioPlayerActivity.FINISHED;
        this.audioPlayerRequest(service_request_1.RequestType.AudioPlayerPlaybackFinished, callback);
        this.playNext();
    }
    playbackStarted(callback) {
        this._activity = AudioPlayerActivity.PLAYING;
        this.audioPlayerRequest(service_request_1.RequestType.AudioPlayerPlaybackStarted, callback);
    }
    playbackStopped(callback) {
        this._activity = AudioPlayerActivity.STOPPED;
        this.audioPlayerRequest(service_request_1.RequestType.AudioPlayerPlaybackStopped, callback);
    }
    audioPlayerRequest(requestType, callback) {
        const self = this;
        const nowPlaying = this.playing();
        const serviceRequest = new service_request_1.ServiceRequest(this.alexa.context());
        serviceRequest.audioPlayerRequest(requestType, nowPlaying.stream.token, nowPlaying.stream.offsetInMilliseconds);
        this.alexa.callSkill(serviceRequest, function (error, response, request) {
            if (callback !== undefined && callback !== null) {
                callback(error, response, request);
            }
            self._emitter.emit(requestType, nowPlaying.clone());
        });
    }
    directivesReceived(directives) {
        for (let directive of directives) {
            this.handleDirective(directive);
        }
    }
    handleDirective(directive) {
        if (directive.type === AudioPlayer.DirectivePlay) {
            let audioItem = new audio_item_1.AudioItem(directive.audioItem);
            let playBehavior = directive.playBehavior;
            this.enqueue(audioItem, playBehavior);
        }
        else if (directive.type === AudioPlayer.DirectiveStop) {
            if (this.suspended()) {
                this._suspended = false;
            }
            else if (this.playing()) {
                this.playbackStopped();
            }
        }
    }
    isPlaying() {
        return (this._activity === AudioPlayerActivity.PLAYING);
    }
    dequeue() {
        const audioItem = this._queue[0];
        this._queue = this._queue.slice(1);
        return audioItem;
    }
    playing() {
        return this._playing;
    }
}
AudioPlayer.DirectivePlay = "AudioPlayer.Play";
AudioPlayer.DirectiveStop = "AudioPlayer.Stop";
AudioPlayer.DirectiveClearQueue = "AudioPlayer.ClearQueue";
AudioPlayer.PlayBehaviorReplaceAll = "REPLACE_ALL";
AudioPlayer.PlayBehaviorEnqueue = "ENQUEUE";
AudioPlayer.PlayBehaviorReplaceEnqueued = "REPLACE_ENQUEUED";
exports.AudioPlayer = AudioPlayer;
;
//# sourceMappingURL=audio-player.js.map