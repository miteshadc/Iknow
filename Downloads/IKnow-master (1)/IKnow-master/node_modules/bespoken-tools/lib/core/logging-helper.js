"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const winston = require("winston");
const string_util_1 = require("./string-util");
class LoggingHelper {
    static setVerbose(enableVerbose) {
        LoggingHelper.verboseEnabled = enableVerbose;
        if (LoggingHelper.verboseEnabled) {
            LoggingHelper.logger.transports.console.level = "verbose";
        }
        else {
            LoggingHelper.logger.transports.console.level = "info";
        }
    }
    static debug(logger, message) {
        LoggingHelper.log("debug", logger, message);
    }
    static verbose(logger, message) {
        LoggingHelper.log("verbose", logger, message);
    }
    static info(logger, message) {
        LoggingHelper.log("info", logger, message);
    }
    static warn(logger, message) {
        LoggingHelper.log("warn", logger, message);
    }
    static error(logger, message) {
        LoggingHelper.log("error", logger, message);
    }
    static log(level, logger, message) {
        let loggerString = string_util_1.StringUtil.rpad(logger, " ", 10).substr(0, 10);
        if (LoggingHelper.cli) {
            winston.log(level, message);
        }
        else {
            winston.log(level, loggerString + "  " + message);
        }
    }
    static prepareForFileLoggingAndDisableConsole(file) {
        LoggingHelper.logger.add(winston.transports.File, {
            formatter: LoggingHelper.cli ? LoggingHelper.cliFormatter : LoggingHelper.formatter,
            level: "error",
            filename: file,
        });
        LoggingHelper.logger.remove(winston.transports.Console);
    }
    static initialize(cli) {
        LoggingHelper.cli = cli;
        winston.clear();
        if (LoggingHelper.cli) {
            LoggingHelper.logger = winston.add(winston.transports.Console, {
                formatter: LoggingHelper.cliFormatter,
                level: "info"
            });
        }
        else {
            LoggingHelper.logger = winston.add(winston.transports.Console, {
                formatter: LoggingHelper.formatter,
                level: "warn"
            });
        }
    }
    static formatter(options) {
        return new Date().toISOString() + " "
            + options.level.toUpperCase() + " "
            + (undefined !== options.message ? options.message : "")
            + (options.meta && Object.keys(options.meta).length ? "\n\t"
                + JSON.stringify(options.meta) : "");
    }
    static cliFormatter(options) {
        let level = options.level.toUpperCase();
        if (level === "VERBOSE") {
            level = "VERB";
        }
        return string_util_1.StringUtil.rpad(level, " ", 5) + " "
            + new Date().toISOString() + " "
            + (undefined !== options.message ? options.message : "")
            + (options.meta && Object.keys(options.meta).length ? "\n\t"
                + JSON.stringify(options.meta) : "");
    }
}
LoggingHelper.cli = false;
LoggingHelper.verboseEnabled = false;
LoggingHelper.logger = null;
LoggingHelper.REQUEST_COLOR = "#ff6633";
LoggingHelper.LINK_COLOR = "#ff6633";
exports.LoggingHelper = LoggingHelper;
//# sourceMappingURL=logging-helper.js.map