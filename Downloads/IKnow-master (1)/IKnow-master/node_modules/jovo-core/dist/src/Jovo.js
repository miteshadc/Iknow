"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const enums_1 = require("./enums");
const SpeechBuilder_1 = require("./SpeechBuilder");
const _get = require("lodash.get");
const _set = require("lodash.set");
const User_1 = require("./User");
const Cms_1 = require("./Cms");
const Log_1 = require("./Log");
class Jovo extends events_1.EventEmitter {
    constructor(app, host) {
        super();
        this.$speech = new SpeechBuilder_1.SpeechBuilder();
        this.$reprompt = new SpeechBuilder_1.SpeechBuilder();
        this.$requestSessionAttributes = {};
        this.setMaxListeners(0);
        this.$jovo = this;
        this.$host = host;
        this.$app = app;
        this.$data = {};
        this.$session = {
            $data: {}
        };
        this.$type = {};
        this.$inputs = {};
        this.$output = {};
        this.$request = undefined;
        this.$response = undefined;
        this.$plugins = {};
        this.$user = new User_1.User(this);
        this.$cms = new Cms_1.Cms();
    }
    /**
     * Returns UserID
     * @deprecated Use this.$user.getId() instead.
     * @public
     * @return {string}
     */
    getUserId() {
        return this.$user.getId();
    }
    /**
     * Returns state value stored in the request session
     * @return {string}
     */
    getState() {
        return this.getSessionAttribute(enums_1.SessionConstants.STATE);
    }
    /**
     * Saves state to sessionAttributes
     * @param {String} state
     * @return {Jovo}
     */
    setState(state) {
        if (typeof state === 'undefined') {
            this.removeState();
        }
        else {
            this.setSessionAttribute(enums_1.SessionConstants.STATE, state);
        }
        return this;
    }
    /**
     * Removes state from session
     * @return {Jovo}
     */
    removeState() {
        if (this.$session && this.$session.$data[enums_1.SessionConstants.STATE]) {
            delete this.$session.$data[enums_1.SessionConstants.STATE];
        }
        return this;
    }
    /**
     * Returns session data value for given path
     * @param {string=} path
     * @return {any}
     */
    getSessionData(path) {
        if (path) {
            return this.getSessionAttribute(path);
        }
        else {
            return this.getSessionAttributes();
        }
    }
    /**
     * Returns session attribute value for given path
     * @param {string} path
     * @return {any}
     */
    getSessionAttribute(path) {
        if (this.$session) {
            return _get(this.$session.$data, path);
        }
        return;
    }
    /**
     * Returns full session attributes obj
     * @return {any}
     */
    getSessionAttributes() {
        if (this.$session) {
            return this.$session.$data;
        }
        return;
    }
    setSessionData(objOrPath, value) {
        if (typeof objOrPath === 'string') {
            return this.setSessionAttribute(objOrPath, value);
        }
        else {
            return this.setSessionAttributes(objOrPath);
        }
    }
    /**
     * Sets session attribute for given path
     * @param {string} path
     * @param {any} value
     * @return {Jovo} this
     */
    setSessionAttribute(path, value) {
        if (this.$session) {
            _set(this.$session.$data, path, value);
        }
        return this;
    }
    /**
     * Adds session data object for given path
     * @param {string} path
     * @param {any} value
     * @return {Jovo} this
     */
    addSessionData(path, value) {
        return this.setSessionAttribute(path, value);
    }
    /**
     * Adds session attribute for given path
     * @param {string} path
     * @param {any} value
     * @return {Jovo} this
     */
    addSessionAttribute(path, value) {
        return this.setSessionAttribute(path, value);
    }
    /**
     * Sets full session attributes obj
     * @public
     * @param {any} sessionData
     * @return {Jovo} this
     */
    setSessionAttributes(sessionData) {
        if (this.$session) {
            this.$session.$data = sessionData;
        }
        return this;
    }
    /**
     * Returns access token
     * @deprecated use this.$request.getAccessToken() instead
     * @returns {string}
     */
    getAccessToken() {
        return this.$request.getAccessToken();
    }
    /**
     * Returns request intent name
     * @deprecated use this.$request.getIntentName() instead
     * @returns {string}
     */
    getIntentName() {
        return this.$request.getIntentName();
    }
    /**
     * Responds with the given text and ends session
     * Transforms plaintext to SSML
     * @public
     * @param {string|SpeechBuilder} speech Plaintext or SSML
     */
    tell(speech) {
        delete this.$output.ask;
        this.$output.tell = {
            speech: speech.toString()
        };
        return this;
    }
    /**
     * Says speech and waits for answer from user.
     * Reprompt when user input fails.
     * Keeps session open.
     * @public
     * @param {string|SpeechBuilder} speech
     * @param {string|SpeechBuilder|Array<SpeechBuilder>|Array<string>} reprompt
     */
    ask(speech, reprompt) {
        delete this.$output.tell;
        if (!reprompt) {
            reprompt = speech;
        }
        this.$output.ask = {
            speech: speech.toString(),
            reprompt: reprompt.toString()
        };
        return this;
    }
    /**
     * Maps incoming request input key names with
     * keys from the inputMap
     * @param {*} inputMap
     */
    mapInputs(inputMap) {
        const mappedInputs = {};
        Object.keys(this.$inputs).forEach((inputKey) => {
            if (inputMap[inputKey]) {
                Log_1.Log.verbose(`Mapping input key ${inputKey} to ${inputMap[inputKey]}.`);
                mappedInputs[inputMap[inputKey]] = this.$inputs[inputKey];
            }
            else {
                mappedInputs[inputKey] = this.$inputs[inputKey];
            }
        });
        this.$inputs = mappedInputs;
    }
    /**
     * Get input object by name
     * @public
     * @param {string} key
     * @return {*}
     */
    getInput(key) {
        return _get(this.$inputs, key);
    }
    /**
     * Sets output object
     * @public
     * @param {Output} obj
     * @return {Jovo}
     */
    setOutput(obj) {
        Object.assign(this.$output, obj);
        return this;
    }
    /**
     * Set raw json response.
     * @param obj
     */
    setResponseObject(obj) {
        this.$rawResponseJson = obj;
    }
    /**
     * Shows simple card to response
     * @public
     * @param {string} title
     * @param {string} content
     * @return {Jovo}
     */
    showSimpleCard(title, content) {
        this.$output.card = {
            SimpleCard: {
                title,
                content
            }
        };
        return this;
    }
    /**
     * Shows image card to response
     * @public
     * @param {string} title
     * @param {string} content
     * @param {string} imageUrl secure url
     * @return {Jovo}
     */
    showImageCard(title, content, imageUrl) {
        this.$output.card = {
            ImageCard: {
                title,
                content,
                imageUrl,
            }
        };
        return this;
    }
    /**
     * Shows account linking card to response
     * @public
     * @return {Jovo}
     */
    showAccountLinkingCard() {
        this.$output.card = {
            AccountLinkingCard: {}
        };
        return this;
    }
    /**
     * Fires respond event and ends session.
     * @deprecated
     * @public
     */
    endSession() {
        console.log('endSession() is obsolete in v2');
    }
}
exports.Jovo = Jovo;
//# sourceMappingURL=Jovo.js.map