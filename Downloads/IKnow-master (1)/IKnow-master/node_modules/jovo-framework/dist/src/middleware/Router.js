"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jovo_core_1 = require("jovo-core");
const _merge = require("lodash.merge");
const _get = require("lodash.get");
const _set = require("lodash.set");
class Router {
    constructor(config) {
        this.config = {
            intentMap: {},
            intentsToSkipUnhandled: [],
        };
        if (config) {
            this.config = _merge(this.config, config);
        }
    }
    install(app) {
        app.middleware('router').use(this.router.bind(this));
    }
    uninstall(app) {
    }
    async router(handleRequest) {
        jovo_core_1.Log.white().verbose(jovo_core_1.Log.header('Jovo router ', 'framework'));
        if (!handleRequest.jovo) {
            return;
        }
        if (!handleRequest.jovo.$type || !handleRequest.jovo.$type.type) {
            throw new Error(`Couldn't access request type`);
        }
        let route = {
            type: handleRequest.jovo.$type.type,
            path: handleRequest.jovo.$type.type,
        };
        if (handleRequest.jovo.$type.type &&
            handleRequest.jovo.$type.subType) {
            route.path = `${handleRequest.jovo.$type.type}["${handleRequest.jovo.$type.subType}"]`;
        }
        if (route.type === jovo_core_1.EnumRequestType.INTENT) {
            // do intent stuff
            if (!handleRequest.jovo.$nlu ||
                !handleRequest.jovo.$nlu.intent) {
                throw new Error(`Couldn't get route for intent request.`);
            }
            const intent = Router.mapIntentName(this.config, handleRequest.jovo.$nlu.intent.name);
            route = Router.intentRoute(handleRequest.jovo.$handlers, handleRequest.jovo.getState(), intent, handleRequest.jovo.$app.config.intentsToSkipUnhandled);
        }
        else if (route.type === jovo_core_1.EnumRequestType.END) {
            // do end stuff
            if (typeof _get(handleRequest.app.config, `handlers.${jovo_core_1.EnumRequestType.END}`) === 'function') {
                route.path = jovo_core_1.EnumRequestType.END;
            }
        }
        else if (route.type === jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED) {
            if (typeof _get(handleRequest.jovo, `$handlers.${jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED}`) === 'function') {
                route.path = jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED;
            }
        }
        else if (route.type === jovo_core_1.EnumRequestType.AUDIOPLAYER) {
            route.path = `${jovo_core_1.EnumRequestType.AUDIOPLAYER}["${handleRequest.jovo.$type.subType}"]`;
        }
        else if (route.type === jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED) {
            // workaround
            route = Router.intentRoute(handleRequest.jovo.$handlers, handleRequest.jovo.getState(), jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED, handleRequest.jovo.$app.config.intentsToSkipUnhandled);
            route.type = jovo_core_1.EnumRequestType.ON_ELEMENT_SELECTED;
            if (typeof _get(handleRequest.jovo.$handlers, route.path) === 'object') {
                route.path += '.' + handleRequest.jovo.$type.subType;
            }
        }
        _set(handleRequest.jovo.$plugins, 'Router.route', route);
        jovo_core_1.Log.yellow().verbose('Route object:');
        jovo_core_1.Log.yellow().verbose(`${JSON.stringify(route, null, '\t')}`);
    }
    static intentRoute(handlers, state, intent, intentsToSkipUnhandled) {
        let _state = state + '';
        const _intent = intent + '';
        let path = state ?
            state + '.' + intent : intent;
        // rewrite path if there is a dot in the intent name
        if (_intent && _intent.indexOf('.') > -1) {
            path = state ? state : '';
            path += '["' + _intent + '"]';
        }
        if (_get(handlers, path)) {
            return {
                path,
                state,
                intent,
                type: jovo_core_1.EnumRequestType.INTENT,
            };
        }
        if (_state) {
            while (_state !== '') {
                if (_get(handlers, _state + '["' + _intent + '"]')) {
                    path = _state + '["' + _intent + '"]';
                    return {
                        path,
                        state,
                        intent,
                        type: jovo_core_1.EnumRequestType.INTENT,
                    };
                }
                // State 'unhandled' is available and intent is not in intentsToSkipUnhandled
                if (_get(handlers, _state + '.' + jovo_core_1.EnumRequestType.UNHANDLED)) {
                    if (!intentsToSkipUnhandled || intentsToSkipUnhandled.indexOf(_intent) === -1) {
                        path = _state + '.' + jovo_core_1.EnumRequestType.UNHANDLED;
                        return {
                            path,
                            state,
                            intent,
                            type: jovo_core_1.EnumRequestType.INTENT,
                        };
                    }
                }
                _state = Router.getLastLevel(_state);
            }
            // is intent in global?
            if (_get(handlers, _intent)) {
                return {
                    path: _intent,
                    state,
                    intent,
                    type: jovo_core_1.EnumRequestType.INTENT,
                };
            }
        }
        const pathToUnhandled = _state ? _state + '.' + jovo_core_1.EnumRequestType.UNHANDLED : jovo_core_1.EnumRequestType.UNHANDLED;
        if (_get(handlers, pathToUnhandled)) {
            path = pathToUnhandled;
        }
        return {
            path,
            state,
            intent,
            type: jovo_core_1.EnumRequestType.INTENT,
        };
    }
    /**
     * Returns last level of path
     * @param {string} route
     * @return {string}
     */
    static getLastLevel(route) {
        let level = '';
        if (route.indexOf('.')) {
            level = route.substr(0, route.lastIndexOf('.'));
        }
        return level;
    }
    /**
     * Maps given intent by the platform with a map in the config
     *
     * {
     *     'AMAZON.StopIntent': 'StopIntent',
     * }
     *
     * @param {Config} appConfig
     * @param {string} intentName
     * @returns {string}
     */
    static mapIntentName(appConfig, intentName) {
        // use intent mapping if set
        if (appConfig.intentMap && appConfig.intentMap[intentName]) {
            jovo_core_1.Log.verbose(`Mapping intent from ${intentName} to ${appConfig.intentMap[intentName]}`);
            return appConfig.intentMap[intentName];
        }
        return intentName;
    }
}
exports.Router = Router;
//# sourceMappingURL=Router.js.map