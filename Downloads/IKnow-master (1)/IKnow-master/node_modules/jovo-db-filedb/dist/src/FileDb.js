"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jovo_core_1 = require("jovo-core");
const path = require("path");
const fs = require("fs");
const _get = require("lodash.get");
const _set = require("lodash.set");
const _merge = require("lodash.merge");
class FileDb {
    constructor(config) {
        this.needsWriteFileAccess = true;
        this.config = {
            pathToFile: './../db/db.json',
            primaryKeyColumn: 'userId',
        };
        if (config) {
            this.config = _merge(this.config, config);
        }
    }
    install(app) {
        const pathToFile = this.config.pathToFile;
        FileDb.validatePathToFile(this.config);
        _set(this, 'config.pathToFile', pathToFile);
        // create file
        try {
            if (!fs.existsSync(path.dirname(pathToFile))) {
                FileDb.mkDirByPathSync(path.dirname(pathToFile), false);
            }
            if (!fs.existsSync(pathToFile)) {
                fs.writeFileSync(pathToFile, '[]');
                jovo_core_1.Log.info(jovo_core_1.Log.header('INFO: Local FileDb', 'db-filedb'));
                jovo_core_1.Log.info(`${path.resolve(pathToFile)} created!`);
                jovo_core_1.Log.info();
                jovo_core_1.Log.info('More Info: >> https://www.jovo.tech/docs/databases/file-db');
                jovo_core_1.Log.info(jovo_core_1.Log.header());
            }
            app.$db = this;
        }
        catch (e) {
        }
    }
    uninstall(app) {
    }
    /**
     * Returns object for given primaryKey
     * @param {string} primaryKey
     * @return {Promise<any>}
     */
    async load(primaryKey) {
        if (!fs.existsSync(this.config.pathToFile)) {
            throw new jovo_core_1.JovoError(`File db ${this.config.pathToFile} does not exist.`, jovo_core_1.ErrorCode.ERR_PLUGIN, 'jovo-db-filedb', undefined, `Restart the Jovo app. ${this.config.pathToFile} will be created automatically.`);
        }
        jovo_core_1.Log.verbose(`Loading data from: ${this.config.pathToFile}`);
        const data = await this.readFile(this.config.pathToFile); // tslint:disable-line
        const users = data.length > 0 ? JSON.parse(data) : [];
        const userData = users.find((o) => {
            return o[this.config.primaryKeyColumn] === primaryKey;
        });
        return Promise.resolve(userData);
    }
    async save(primaryKey, key, data) {
        if (!fs.existsSync(this.config.pathToFile)) {
            throw new jovo_core_1.JovoError(`File db ${this.config.pathToFile} does not exist.`, jovo_core_1.ErrorCode.ERR_PLUGIN, 'jovo-db-filedb', undefined, `Restart the Jovo app. ${this.config.pathToFile} will be created automatically.`);
        }
        const oldData = await this.readFile(this.config.pathToFile); // tslint:disable-line
        const users = oldData.length > 0 ? JSON.parse(oldData) : [];
        // find data for user with this primaryKey
        const userData = users.find((o) => {
            return o[this.config.primaryKeyColumn] === primaryKey;
        });
        if (userData) {
            _set(userData, key, data);
        }
        else {
            const newData = {}; // tslint:disable-line
            newData[this.config.primaryKeyColumn] = primaryKey;
            _set(newData, key, data);
            users.push(newData);
        }
        jovo_core_1.Log.verbose(`Saving data to: ${this.config.pathToFile}`);
        return this.saveFile(this.config.pathToFile, users);
    }
    async delete(primaryKey) {
        if (!fs.existsSync(this.config.pathToFile)) {
            throw new jovo_core_1.JovoError(`File db ${this.config.pathToFile} does not exist.`, jovo_core_1.ErrorCode.ERR_PLUGIN, 'jovo-db-filedb', undefined, `Restart the Jovo app. ${this.config.pathToFile} will be created automatically.`);
        }
        const data = await this.readFile(this.config.pathToFile); // tslint:disable-line
        let users = data.length > 0 ? JSON.parse(data) : [];
        let rowsAffected = 0;
        for (let i = 0; i < users.length; i++) {
            if (users[i][this.config.primaryKeyColumn] === primaryKey) {
                delete users[i];
                rowsAffected++;
            }
        }
        users = users.filter((n) => n); // remove null
        await this.saveFile(this.config.pathToFile, users);
        return Promise.resolve(rowsAffected);
    }
    async readFile(filename) {
        return new Promise((resolve, reject) => {
            fs.readFile(filename, 'utf8', (err, data) => {
                if (err) {
                    return reject(err);
                }
                resolve(data);
            });
        });
    }
    async saveFile(filename, data) {
        return new Promise((resolve, reject) => {
            fs.writeFile(filename, JSON.stringify(data, null, '\t'), (err) => {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    }
    static validatePathToFile(config) {
        if (!_get(config, 'pathToFile')) {
            throw new jovo_core_1.JovoError('InitializationError: pathToFile not set.', jovo_core_1.ErrorCode.ERR_PLUGIN, 'jovo-db-filedb');
        }
        if ((/[^a-z0-9_/\.:\\-]/gi).test(config.pathToFile)) {
            throw new jovo_core_1.JovoError('InitializationError: pathToFile not valid.', jovo_core_1.ErrorCode.ERR_PLUGIN, 'jovo-db-filedb');
        }
        if (path.extname(config.pathToFile) !== '.json') {
            throw new jovo_core_1.JovoError('InitializationError: Invalid file FileDB extension. It must be .json', jovo_core_1.ErrorCode.ERR_PLUGIN, 'jovo-db-filedb');
        }
    }
    /**
     * Creates paths recursively
     * @param {string} targetDir
     * @param {boolean} isRelativeToScript
     */
    static mkDirByPathSync(targetDir, isRelativeToScript) {
        const sep = path.sep;
        const initDir = path.isAbsolute(targetDir) ? sep : '';
        const baseDir = isRelativeToScript ? __dirname : '.';
        targetDir.split(sep).reduce((parentDir, childDir) => {
            const curDir = path.resolve(baseDir, parentDir, childDir);
            try {
                if (!fs.existsSync(curDir)) {
                    fs.mkdirSync(curDir);
                }
            }
            catch (err) {
                if (err.code !== 'EEXIST') {
                    throw err;
                }
                console.log(`Directory ${curDir} already exists!`);
            }
            return curDir;
        }, initDir);
    }
}
exports.FileDb = FileDb;
//# sourceMappingURL=FileDb.js.map